---
title: "Report for Mariëlle"
author: "Jan-Ole Koslik and Leon Seelmeyer"
date: "`r Sys.Date()`"
output:
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



```{r, echo = FALSE, message = FALSE}
# defining all functions
library(sn)

# HMM functions -----------------------------------------------------------

zgamma_scalar = function(x, mu, sigma, p){
  if(x == 0){return(p)}
  else{return((1-p)*dgamma(x, shape = mu^2/sigma^2, scale = sigma^2/mu))}
}
zgamma = function(x, mu, sigma, p){
  return(sapply(x, zgamma_scalar, mu = mu, sigma = sigma, p = p))
}


# Likelihoods -------------------------------------------------------------

# likelihood for 3D-time series assuming contemporaneous conditional independence
mllk = function(theta.star, X, N){
  Gamma = diag(N)
  Gamma[!Gamma] = exp(theta.star[1:((N-1)*N)])
  Gamma = Gamma/rowSums(Gamma)
  delta = solve(t(diag(N)-Gamma+1),rep(1,N), tol = 1e-18) # stationary, smaller tolerance to avoid numerical problems
  
  # gamma distribution: Step length
  mu.g = exp(theta.star[(N-1)*N+1:N]) # means of gamma distributions
  sigma.g = exp(theta.star[(N-1)*N+N+1:N]) # sds of gamma distributions
  
  # beta distribution: Turning angle/ pi
  alpha = exp(theta.star[(N-1)*N+2*N+1:N]) # shape1 parameters of beta distributions
  beta = exp(theta.star[(N-1)*N+3*N+1:N]) # shape2 parameters of beta distributions
  p.b = plogis(theta.star[(N-1)*N+4*N+1:N])
  
  # normal distribution: Height first difference
  mu = theta.star[(N-1)*N+5*N+1:N] # means of normal distributions
  sigma = exp(theta.star[(N-1)*N+6*N+1:N]) # sds of normal distributions
  
  allprobs = matrix(1, nrow(X), N)
  ind = which(!is.na(X$step) & !is.na(X$angle) & !is.na(X$height.fd)) # Fragen wie wir das machen --> sonst immer gar keine Information nur weil in angle Zeitreihe so viele NAs
  
  for (j in 1:N){ # allprobs matrix
    allprobs[ind,j] =
      dgamma(X$step[ind], shape = mu.g[j]^2/sigma.g[j]^2, scale = sigma.g[j]^2/mu.g[j])* #gamma
      zbeta(X$angle[ind], shape1 = alpha[j], shape2 = beta[j], p = p.b[j])* # beta
      dnorm(X$height.fd[ind], mean = mu[j], sd = sigma[j]) # normal
  }
  
  # forward algorithm to compute the log-likelihood
  foo = delta%*%diag(allprobs[1,])
  l = log(sum(foo))
  phi = foo/sum(foo)
  for (t in 2:nrow(X)){
    foo = phi%*%Gamma%*%diag(allprobs[t,])
    l = l+log(sum(foo))
    phi = foo/sum(foo)
  }
  
  return(-l) 
}

mllk_na = function(theta.star, X, N){
  Gamma = diag(N)
  Gamma[!Gamma] = exp(theta.star[1:((N-1)*N)])
  Gamma = Gamma/rowSums(Gamma)
  delta = solve(t(diag(N)-Gamma+1),rep(1,N), tol = 1e-18) # stationary, smaller tolerance to avoid numerical problems
  
  # gamma distribution: Step length
  mu.g = exp(theta.star[(N-1)*N+1:N]) # means of gamma distributions
  sigma.g = exp(theta.star[(N-1)*N+N+1:N]) # sds of gamma distributions
  
  # beta distribution: Turning angle/ pi
  alpha = exp(theta.star[(N-1)*N+2*N+1:N]) # shape1 parameters of beta distributions
  beta = exp(theta.star[(N-1)*N+3*N+1:N]) # shape2 parameters of beta distributions
  p.b = plogis(theta.star[(N-1)*N+4*N+1:N])
  
  # normal distribution: Height first difference
  mu = theta.star[(N-1)*N+5*N+1:N] # means of normal distributions
  sigma = exp(theta.star[(N-1)*N+6*N+1:N]) # sds of normal distributions
  
  allprobs = matrix(1, nrow(X), N)
  ind1 = which(!is.na(X$step) & !is.na(X$angle) & !is.na(X$height.fd)) # Fragen wie wir das machen --> sonst immer gar keine Information nur weil in angle Zeitreihe so viele NAs
  ind2 = which(!is.na(X$step) & is.na(X$angle) & !is.na(X$height.fd))
  
  for (j in 1:N){ # allprobs matrix
    allprobs[ind1,j] =
      dgamma(X$step[ind1], shape = mu.g[j]^2/sigma.g[j]^2, scale = sigma.g[j]^2/mu.g[j])* #gamma
      zbeta(X$angle[ind1], shape1 = alpha[j], shape2 = beta[j], p = p.b[j])* # beta
      dnorm(X$height.fd[ind1], mean = mu[j], sd = sigma[j]) # normal
    
    allprobs[ind2,j] =
      dgamma(X$step[ind2], shape = mu.g[j]^2/sigma.g[j]^2, scale = sigma.g[j]^2/mu.g[j])* #gamma
      dnorm(X$height.fd[ind2], mean = mu[j], sd = sigma[j]) # normal
  }
  
  # forward algorithm to compute the log-likelihood
  foo = delta%*%diag(allprobs[1,])
  l = log(sum(foo))
  phi = foo/sum(foo)
  for (t in 2:nrow(X)){
    foo = phi%*%Gamma%*%diag(allprobs[t,])
    l = l+log(sum(foo))
    phi = foo/sum(foo)
  }
  
  return(-l) 
}


mllk_sn = function(theta.star, X, N){
  # avoid zero beta
  # X$angle[which(X$angle == 0)] = runif(length(X$angle[which(X$angle == 0)]), 0, 0.03)
  
  Gamma = diag(N)
  Gamma[!Gamma] = exp(theta.star[1:((N-1)*N)])
  Gamma = Gamma/rowSums(Gamma)
  delta = solve(t(diag(N)-Gamma+1),rep(1,N), tol = 1e-40) # stationary, smaller tolerance to avoid numerical problems
  
  # gamma distribution: Step length
  mu.g = exp(theta.star[(N-1)*N+1:N]) # means of gamma distributions
  sigma.g = exp(theta.star[(N-1)*N+N+1:N]) # sds of gamma distributions
  
  # beta distribution: Turning angle/ pi
  alpha = exp(theta.star[(N-1)*N+2*N+1:N]) # shape1 parameters of beta distributions
  beta = exp(theta.star[(N-1)*N+3*N+1:N]) # shape2 parameters of beta distributions

  # normal distribution: Height first difference
  xi = theta.star[(N-1)*N+4*N+1:N] # means of normal distributions
  omega = exp(theta.star[(N-1)*N+5*N+1:N]) # sds of normal distributions
  al = theta.star[(N-1)*N+6*N+1:N]
  
  allprobs = matrix(1, nrow(X), N)
  ind = which(!is.na(X$step) & !is.na(X$angle) & !is.na(X$height.fd)) # Fragen wie wir das machen --> sonst immer gar keine Information nur weil in angle Zeitreihe so viele NAs
  
  for (j in 1:N){ # allprobs matrix
    allprobs[ind,j] =
      dgamma(X$step[ind], shape = mu.g[j]^2/sigma.g[j]^2, scale = sigma.g[j]^2/mu.g[j])* #gamma
      dbeta(X$angle[ind], shape1 = alpha[j], shape2 = beta[j])* # beta
      dsn(X$height.fd[ind], xi = xi[j], omega = omega[j], alpha = al[j]) # skew normal
  }
  
  # forward algorithm to compute the log-likelihood
  foo = delta%*%diag(allprobs[1,])
  l = log(sum(foo))
  phi = foo/sum(foo)
  for (t in 2:nrow(X)){
    foo = phi%*%Gamma%*%diag(allprobs[t,])
    l = l+log(sum(foo))
    phi = foo/sum(foo)
  }
  
  return(-l) 
}


mllk_na_sn = function(theta.star, X, N){
  Gamma = diag(N)
  Gamma[!Gamma] = exp(theta.star[1:((N-1)*N)])
  Gamma = Gamma/rowSums(Gamma)
  delta = solve(t(diag(N)-Gamma+1),rep(1,N), tol = 1e-18) # stationary, smaller tolerance to avoid numerical problems
  
  # gamma distribution: Step length
  mu.g = exp(theta.star[(N-1)*N+1:N]) # means of gamma distributions
  sigma.g = exp(theta.star[(N-1)*N+N+1:N]) # sds of gamma distributions
  
  # beta distribution: Turning angle/ pi
  alpha = exp(theta.star[(N-1)*N+2*N+1:N]) # shape1 parameters of beta distributions
  beta = exp(theta.star[(N-1)*N+3*N+1:N]) # shape2 parameters of beta distributions
  
  # normal distribution: Height first difference
  xi = theta.star[(N-1)*N+4*N+1:N] # means of normal distributions
  omega = exp(theta.star[(N-1)*N+5*N+1:N]) # sds of normal distributions
  al = theta.star[(N-1)*N+6*N+1:N]
  
  allprobs = matrix(1, nrow(X), N)
  ind1 = which(!is.na(X$step) & !is.na(X$angle) & !is.na(X$height.fd)) # Fragen wie wir das machen --> sonst immer gar keine Information nur weil in angle Zeitreihe so viele NAs
  ind2 = which(!is.na(X$step) & is.na(X$angle) & !is.na(X$height.fd))
  
  for (j in 1:N){ # allprobs matrix
    allprobs[ind1,j] =
      dgamma(X$step[ind1], shape = mu.g[j]^2/sigma.g[j]^2, scale = sigma.g[j]^2/mu.g[j])* #gamma
      dbeta(X$angle[ind1], shape1 = alpha[j], shape2 = beta[j])* # beta
      dsn(X$height.fd[ind1], xi = xi[j], omega = omega[j], alpha = al[j]) # skew normal
    
    allprobs[ind2,j] =
      dgamma(X$step[ind2], shape = mu.g[j]^2/sigma.g[j]^2, scale = sigma.g[j]^2/mu.g[j])* #gamma
      dsn(X$height.fd[ind2], xi = xi[j], omega = omega[j], alpha = al[j]) # skew normal
  }
  
  # forward algorithm to compute the log-likelihood
  t1 = Sys.time()
  foo = delta%*%diag(allprobs[1,])
  l = log(sum(foo))
  phi = foo/sum(foo)
  for (t in 2:nrow(X)){
    foo = phi%*%Gamma%*%diag(allprobs[t,])
    l = l+log(sum(foo))
    phi = foo/sum(foo)
  }
  # Doppelschleife über Tage
  # am Ende die log Likelihoods pro Tag addieren!
  # oder parallelisierbar (mclapply())
  Sys.time()-t1
  return(-l) 
}


mllk_na_sn = function(theta.star, X, N){
  days = unique(X$day)
  numdays = length(days)
  
  Gamma = diag(N)
  Gamma[!Gamma] = exp(theta.star[1:((N-1)*N)])
  Gamma = Gamma/rowSums(Gamma)
  delta = solve(t(diag(N)-Gamma+1),rep(1,N), tol = 1e-18) # stationary, smaller tolerance to avoid numerical problems
  
  # gamma distribution: Step length
  mu.g = exp(theta.star[(N-1)*N+1:N]) # means of gamma distributions
  sigma.g = exp(theta.star[(N-1)*N+N+1:N]) # sds of gamma distributions
  
  # beta distribution: Turning angle/ pi
  alpha = exp(theta.star[(N-1)*N+2*N+1:N]) # shape1 parameters of beta distributions
  beta = exp(theta.star[(N-1)*N+3*N+1:N]) # shape2 parameters of beta distributions
  
  # normal distribution: Height first difference
  xi = theta.star[(N-1)*N+4*N+1:N] # means of normal distributions
  omega = exp(theta.star[(N-1)*N+5*N+1:N]) # sds of normal distributions
  al = theta.star[(N-1)*N+6*N+1:N]
  
  allprobs = matrix(1, nrow(X), N)
  ind1 = which(!is.na(X$step) & !is.na(X$angle) & !is.na(X$height.fd)) # Fragen wie wir das machen --> sonst immer gar keine Information nur weil in angle Zeitreihe so viele NAs
  ind2 = which(!is.na(X$step) & is.na(X$angle) & !is.na(X$height.fd))
  
  for (j in 1:N){ # allprobs matrix
    allprobs[ind1,j] =
      dgamma(X$step[ind1], shape = mu.g[j]^2/sigma.g[j]^2, scale = sigma.g[j]^2/mu.g[j])* #gamma
      dbeta(X$angle[ind1], shape1 = alpha[j], shape2 = beta[j])* # beta
      dsn(X$height.fd[ind1], xi = xi[j], omega = omega[j], alpha = al[j]) # skew normal
    
    allprobs[ind2,j] =
      dgamma(X$step[ind2], shape = mu.g[j]^2/sigma.g[j]^2, scale = sigma.g[j]^2/mu.g[j])* #gamma
      dsn(X$height.fd[ind2], xi = xi[j], omega = omega[j], alpha = al[j]) # skew normal
  }
  
  # forward algorithm to compute the log-likelihood
  l = numeric(numdays)
  for(i in 1:numdays){
    index = which(X$day == i)
    
    foo = delta%*%diag(allprobs[index[1],])
    l[i] = log(sum(foo))
    phi = foo/sum(foo)
    
    for (t in 2:length(index)){
      foo = phi%*%Gamma%*%diag(allprobs[index[t],])
      l[i] = l[i]+log(sum(foo))
      phi = foo/sum(foo)
    }
  }
  l = sum(l)
  return(-l) 
}


mllk_na_sn_cov = function(theta.star, X, N){
  coef = matrix(theta.star[1:(2*(N-1)*N)], (N-1)*N, 2)
  
  # gamma distribution: Step length
  mu.g = exp(theta.star[2*(N-1)*N+1:N]) # means of gamma distributions
  sigma.g = exp(theta.star[2*(N-1)*N+N+1:N]) # sds of gamma distributions
  
  # beta distribution: Turning angle/ pi
  alpha = exp(theta.star[2*(N-1)*N+2*N+1:N]) # shape1 parameters of beta distributions
  beta = exp(theta.star[2*(N-1)*N+3*N+1:N]) # shape2 parameters of beta distributions
  
  # normal distribution: Height first difference
  xi = theta.star[2*(N-1)*N+4*N+1:N] # means of normal distributions
  omega = exp(theta.star[2*(N-1)*N+5*N+1:N]) # sds of normal distributions
  al = theta.star[2*(N-1)*N+6*N+1:N]
  
  delta = c(1, exp(theta.star[2*(N-1)*N+7*N+1:(N-1)]))
  delta = delta/sum(delta)
  
  allprobs = matrix(1, nrow(X), N)
  ind1 = which(!is.na(X$step) & !is.na(X$angle) & !is.na(X$height.fd)) # Fragen wie wir das machen --> sonst immer gar keine Information nur weil in angle Zeitreihe so viele NAs
  ind2 = which(!is.na(X$step) & is.na(X$angle) & !is.na(X$height.fd))
  
  for (j in 1:N){ # allprobs matrix
    allprobs[ind1,j] =
      dgamma(X$step[ind1], shape = mu.g[j]^2/sigma.g[j]^2, scale = sigma.g[j]^2/mu.g[j])* #gamma
      dbeta(X$angle[ind1], shape1 = alpha[j], shape2 = beta[j])* # beta
      dsn(X$height.fd[ind1], xi = xi[j], omega = omega[j], alpha = al[j]) # skew normal
    
    allprobs[ind2,j] =
      dgamma(X$step[ind2], shape = mu.g[j]^2/sigma.g[j]^2, scale = sigma.g[j]^2/mu.g[j])* #gamma
      dsn(X$height.fd[ind2], xi = xi[j], omega = omega[j], alpha = al[j]) # skew normal
  }
  
  # forward algorithm to compute the log-likelihood
  foo = delta%*%diag(allprobs[1,])
  l = log(sum(foo))
  phi = foo/sum(foo)
  for (t in 2:nrow(X)){
    eta = coef[,1] + coef[,2]*X$temp[t]
    Gamma = diag(N)
    Gamma[!Gamma] = exp(eta) # dynamically changing Gamma-Matrix
    Gamma = Gamma/rowSums(Gamma)
    
    foo = phi%*%Gamma%*%diag(allprobs[t,])
    l = l+log(sum(foo))
    phi = foo/sum(foo)
  }
  return(-l) 
}


mllk_na_sn_cov2 = function(theta.star, X, N){
  days = unique(X$day)
  numdays = length(days)
  
  coef = matrix(theta.star[1:(2*(N-1)*N)], (N-1)*N, 2)
  
  # gamma distribution: Step length
  mu.g = exp(theta.star[2*(N-1)*N+1:N]) # means of gamma distributions
  sigma.g = exp(theta.star[2*(N-1)*N+N+1:N]) # sds of gamma distributions
  
  # beta distribution: Turning angle/ pi
  alpha = exp(theta.star[2*(N-1)*N+2*N+1:N]) # shape1 parameters of beta distributions
  beta = exp(theta.star[2*(N-1)*N+3*N+1:N]) # shape2 parameters of beta distributions
  
  # normal distribution: Height first difference
  xi = theta.star[2*(N-1)*N+4*N+1:N] # means of normal distributions
  omega = exp(theta.star[2*(N-1)*N+5*N+1:N]) # sds of normal distributions
  al = theta.star[2*(N-1)*N+6*N+1:N]
  
  delta = c(1, exp(theta.star[2*(N-1)*N+7*N+1:(N-1)]))
  delta = delta/sum(delta)
  
  allprobs = matrix(1, nrow(X), N)
  ind1 = which(!is.na(X$step) & !is.na(X$angle) & !is.na(X$height.fd)) # Fragen wie wir das machen --> sonst immer gar keine Information nur weil in angle Zeitreihe so viele NAs
  ind2 = which(!is.na(X$step) & is.na(X$angle) & !is.na(X$height.fd))
  
  for (j in 1:N){ # allprobs matrix
    allprobs[ind1,j] =
      dgamma(X$step[ind1], shape = mu.g[j]^2/sigma.g[j]^2, scale = sigma.g[j]^2/mu.g[j])* #gamma
      dbeta(X$angle[ind1], shape1 = alpha[j], shape2 = beta[j])* # beta
      dsn(X$height.fd[ind1], xi = xi[j], omega = omega[j], alpha = al[j]) # skew normal
    
    allprobs[ind2,j] =
      dgamma(X$step[ind2], shape = mu.g[j]^2/sigma.g[j]^2, scale = sigma.g[j]^2/mu.g[j])* #gamma
      dsn(X$height.fd[ind2], xi = xi[j], omega = omega[j], alpha = al[j]) # skew normal
  }
  
  # forward algorithm to compute the log-likelihood
  l = numeric(numdays)
  # compute the daywise likelihoods seperately and sum up in the end
  for(i in 1:numdays){
    index = which(X$day == i)
    
    # vllt statt delta die hypothetische stationary zu Tagesbeginn oder gleichverteilt
    foo = delta%*%diag(allprobs[index[1],])
    l[i] = log(sum(foo))
    phi = foo/sum(foo)
    
    for (t in 2:length(index)){
      eta = coef[,1] + coef[,2]*X$temp[index[t]]
      Gamma = diag(N)
      Gamma[!Gamma] = exp(eta) # dynamically changing Gamma-Matrix
      Gamma = Gamma/rowSums(Gamma)
      
      foo = phi%*%Gamma%*%diag(allprobs[index[t],])
      l[i] = l[i]+log(sum(foo))
      phi = foo/sum(foo)
    }
  }
  l = sum(l)
  return(-l) 
}


mllk_tod = function(theta.star, X, N){
  days = unique(X$day)
  numdays = length(days)
  
  coef = matrix(theta.star[1:(3*(N-1)*N)], (N-1)*N, 3)
  
  # gamma distribution: Step length
  mu.g = exp(theta.star[3*(N-1)*N+1:N]) # means of gamma distributions
  sigma.g = exp(theta.star[3*(N-1)*N+N+1:N]) # sds of gamma distributions
  
  # beta distribution: Turning angle/ pi
  alpha = exp(theta.star[3*(N-1)*N+2*N+1:N]) # shape1 parameters of beta distributions
  beta = exp(theta.star[3*(N-1)*N+3*N+1:N]) # shape2 parameters of beta distributions
  
  # normal distribution: Height first difference
  xi = theta.star[3*(N-1)*N+4*N+1:N] # means of normal distributions
  omega = exp(theta.star[3*(N-1)*N+5*N+1:N]) # sds of normal distributions
  al = theta.star[3*(N-1)*N+6*N+1:N]
  
  allprobs = matrix(1, nrow(X), N)
  ind1 = which(!is.na(X$step) & !is.na(X$angle) & !is.na(X$height.fd)) # Fragen wie wir das machen --> sonst immer gar keine Information nur weil in angle Zeitreihe so viele NAs
  ind2 = which(!is.na(X$step) & is.na(X$angle) & !is.na(X$height.fd))
  
  for (j in 1:N){ # allprobs matrix
    allprobs[ind1,j] =
      dgamma(X$step[ind1], shape = mu.g[j]^2/sigma.g[j]^2, scale = sigma.g[j]^2/mu.g[j])* #gamma
      dbeta(X$angle[ind1], shape1 = alpha[j], shape2 = beta[j])* # beta
      dsn(X$height.fd[ind1], xi = xi[j], omega = omega[j], alpha = al[j]) # skew normal
    
    allprobs[ind2,j] =
      dgamma(X$step[ind2], shape = mu.g[j]^2/sigma.g[j]^2, scale = sigma.g[j]^2/mu.g[j])* #gamma
      dsn(X$height.fd[ind2], xi = xi[j], omega = omega[j], alpha = al[j]) # skew normal
  }
  
  # forward algorithm to compute the log-likelihood
  l = numeric(numdays)
  # compute the daywise likelihoods seperately and sum up in the end
  for(i in 1:numdays){
    index = which(X$day == i)
    
    eta = coef[,1] + coef[,2]*sin(2*pi*X$time[index[1]]/24) + coef[,3]*cos(2*pi*X$time[index[1]]/24)
      
    Gamma = diag(N)
    Gamma[!Gamma] = exp(eta) # dynamically changing Gamma-Matrix
    Gamma = Gamma/rowSums(Gamma)
    delta = solve(t(diag(N)-Gamma+1),rep(1,N), tol = 1e-18)
    
    # vllt statt delta die hypothetische stationary zu Tagesbeginn oder gleichverteilt
    foo = delta%*%diag(allprobs[index[1],])
    l[i] = log(sum(foo))
    phi = foo/sum(foo)
    
    for (t in 2:length(index)){
      eta = coef[,1] + coef[,2]*sin(2*pi*X$time[index[t]]/24) + coef[,3]*cos(2*pi*X$time[index[t]]/24)
      Gamma = diag(N)
      Gamma[!Gamma] = exp(eta) # dynamically changing Gamma-Matrix
      Gamma = Gamma/rowSums(Gamma)
      
      foo = phi%*%Gamma%*%diag(allprobs[index[t],])
      l[i] = l[i]+log(sum(foo))
      phi = foo/sum(foo)
    }
  }
  l = sum(l)
  return(-l) 
}


# Likelihood Funktion with:
# - NA handling for turning angle
# - Skew normal distribution for height.fd
# - Seperate daily computation of the likelihood 
# - Covariates: Temperature and Time of Day

mllk_tt = function(theta.star, X, N){
  days = unique(X$day)
  numdays = length(days)
  
  coef = matrix(theta.star[1:(4*(N-1)*N)], (N-1)*N, 4)
  
  # gamma distribution: Step length
  mu.g = exp(theta.star[4*(N-1)*N+1:N]) # means of gamma distributions
  sigma.g = exp(theta.star[4*(N-1)*N+N+1:N]) # sds of gamma distributions
  
  # beta distribution: Turning angle/ pi
  alpha = exp(theta.star[4*(N-1)*N+2*N+1:N]) # shape1 parameters of beta distributions
  beta = exp(theta.star[4*(N-1)*N+3*N+1:N]) # shape2 parameters of beta distributions
  
  # skew normal distribution: Height first difference
  xi = theta.star[4*(N-1)*N+4*N+1:N] # means of normal distributions
  omega = exp(theta.star[4*(N-1)*N+5*N+1:N]) # sds of normal distributions
  al = theta.star[4*(N-1)*N+6*N+1:N]
  
  delta = c(1, exp(theta.star[4*(N-1)*N+7*N+1:(N-1)]))
  delta = delta/sum(delta)
  
  allprobs = matrix(1, nrow(X), N)
  ind1 = which(!is.na(X$step) & !is.na(X$angle) & !is.na(X$height.fd)) # Fragen wie wir das machen --> sonst immer gar keine Information nur weil in angle Zeitreihe so viele NAs
  ind2 = which(!is.na(X$step) & is.na(X$angle) & !is.na(X$height.fd))
  
  for (j in 1:N){ # allprobs matrix
    allprobs[ind1,j] =
      dgamma(X$step[ind1], shape = mu.g[j]^2/sigma.g[j]^2, scale = sigma.g[j]^2/mu.g[j])* #gamma
      dbeta(X$angle[ind1], shape1 = alpha[j], shape2 = beta[j])* # beta
      dsn(X$height.fd[ind1], xi = xi[j], omega = omega[j], alpha = al[j]) # skew normal
    
    allprobs[ind2,j] =
      dgamma(X$step[ind2], shape = mu.g[j]^2/sigma.g[j]^2, scale = sigma.g[j]^2/mu.g[j])* #gamma
      dsn(X$height.fd[ind2], xi = xi[j], omega = omega[j], alpha = al[j]) # skew normal
  }
  
  # forward algorithm to compute the log-likelihood
  l = numeric(numdays)
  # compute the daywise likelihoods seperately and sum up in the end
  for(i in 1:numdays){
    index = which(X$day == i)
    
    eta = coef[,1] + coef[,2]*sin(2*pi*X$time[index[1]]/24) + coef[,3]*cos(2*pi*X$time[index[1]]/24) + 
      coef[,4]*X$temp[index[1]]
    
    # vllt statt delta die hypothetische stationary zu Tagesbeginn oder gleichverteilt
    foo = delta%*%diag(allprobs[index[1],])
    l[i] = log(sum(foo))
    phi = foo/sum(foo)
    
    for (t in 2:length(index)){
      eta = coef[,1] + coef[,2]*sin(2*pi*X$time[index[t]]/24) + coef[,3]*cos(2*pi*X$time[index[t]]/24) +
        coef[,4]*X$temp[index[t]]
      Gamma = diag(N)
      Gamma[!Gamma] = exp(eta) # dynamically changing Gamma-Matrix
      Gamma = Gamma/rowSums(Gamma)
      
      foo = phi%*%Gamma%*%diag(allprobs[index[t],])
      l[i] = l[i]+log(sum(foo))
      phi = foo/sum(foo)
    }
  }
  l = sum(l)
  return(-l) 
}


mllk_landform = function(theta.star, X, N){
  days = unique(X$day)
  numdays = length(days)
  
  coef = matrix(theta.star[1:(6*(N-1)*N)], (N-1)*N, 6)
  
  # gamma distribution: Step length
  mu.g = exp(theta.star[6*(N-1)*N+1:N]) # means of gamma distributions
  sigma.g = exp(theta.star[6*(N-1)*N+N+1:N]) # sds of gamma distributions
  
  # beta distribution: Turning angle/ pi
  alpha = exp(theta.star[6*(N-1)*N+2*N+1:N]) # shape1 parameters of beta distributions
  beta = exp(theta.star[6*(N-1)*N+3*N+1:N]) # shape2 parameters of beta distributions
  
  # skew normal distribution: Height first difference
  xi = theta.star[6*(N-1)*N+4*N+1:N] # means of normal distributions
  omega = exp(theta.star[6*(N-1)*N+5*N+1:N]) # sds of normal distributions
  al = theta.star[6*(N-1)*N+6*N+1:N]
  
  delta = c(1, exp(theta.star[6*(N-1)*N+7*N+1:(N-1)]))
  delta = delta/sum(delta)
  
  allprobs = matrix(1, nrow(X), N)
  ind1 = which(!is.na(X$step) & !is.na(X$angle) & !is.na(X$height.fd)) # Fragen wie wir das machen --> sonst immer gar keine Information nur weil in angle Zeitreihe so viele NAs
  ind2 = which(!is.na(X$step) & is.na(X$angle) & !is.na(X$height.fd))
  
  for (j in 1:N){ # allprobs matrix
    allprobs[ind1,j] =
      dgamma(X$step[ind1], shape = mu.g[j]^2/sigma.g[j]^2, scale = sigma.g[j]^2/mu.g[j])* #gamma
      dbeta(X$angle[ind1], shape1 = alpha[j], shape2 = beta[j])* # beta
      dsn(X$height.fd[ind1], xi = xi[j], omega = omega[j], alpha = al[j]) # skew normal
    
    allprobs[ind2,j] =
      dgamma(X$step[ind2], shape = mu.g[j]^2/sigma.g[j]^2, scale = sigma.g[j]^2/mu.g[j])* #gamma
      dsn(X$height.fd[ind2], xi = xi[j], omega = omega[j], alpha = al[j]) # skew normal
  }
  
  # forward algorithm to compute the log-likelihood
  l = numeric(numdays)
  # compute the daywise likelihoods seperately and sum up in the end
  for(i in 1:numdays){
    index = which(X$day == i)
    
    eta = coef[,1] + coef[,2]*X$lower_slope[index[1]] + coef[,3]*X$mountain_divide[index[1]] + 
      coef[,4]*X$peak_ridge[index[1]] + coef[,5]*X$upper_slope[index[1]] + 
      coef[,6]*X$valley[index[1]]
    
    # vllt statt delta die hypothetische stationary zu Tagesbeginn oder gleichverteilt
    foo = delta%*%diag(allprobs[index[1],])
    l[i] = log(sum(foo))
    phi = foo/sum(foo)
    
    for (t in 2:length(index)){
      eta = coef[,1] + coef[,2]*X$lower_slope[index[t]] + coef[,3]*X$mountain_divide[index[t]] + 
        coef[,4]*X$peak_ridge[index[t]] + coef[,5]*X$upper_slope[index[t]] + 
        coef[,6]*X$valley[index[t]]
      
      Gamma = diag(N)
      Gamma[!Gamma] = exp(eta) # dynamically changing Gamma-Matrix
      Gamma = Gamma/rowSums(Gamma)
      
      foo = phi%*%Gamma%*%diag(allprobs[index[t],])
      l[i] = l[i]+log(sum(foo))
      phi = foo/sum(foo)
    }
  }
  l = sum(l)
  return(-l) 
}



mllk_ttl = function(theta.star, X, N){
  numdays = max(X$day)
  
  coef = matrix(theta.star[1:(9*(N-1)*N)], (N-1)*N, 9)
  
  # gamma distribution: Step length
  mu.g = exp(theta.star[9*(N-1)*N+1:N]) # means of gamma distributions
  sigma.g = exp(theta.star[9*(N-1)*N+N+1:N]) # sds of gamma distributions
  
  # beta distribution: Turning angle/ pi
  alpha = exp(theta.star[9*(N-1)*N+2*N+1:N]) # shape1 parameters of beta distributions
  beta = exp(theta.star[9*(N-1)*N+3*N+1:N]) # shape2 parameters of beta distributions
  
  # skew normal distribution: Height first difference
  xi = theta.star[9*(N-1)*N+4*N+1:N] # means of normal distributions
  omega = exp(theta.star[9*(N-1)*N+5*N+1:N]) # sds of normal distributions
  al = theta.star[9*(N-1)*N+6*N+1:N]
  
  delta = c(1, exp(theta.star[9*(N-1)*N+7*N+1:(N-1)]))
  delta = delta/sum(delta)
  
  allprobs = matrix(1, nrow(X), N)
  ind1 = which(!is.na(X$step) & !is.na(X$angle) & !is.na(X$height.fd)) # Fragen wie wir das machen --> sonst immer gar keine Information nur weil in angle Zeitreihe so viele NAs
  ind2 = which(!is.na(X$step) & is.na(X$angle) & !is.na(X$height.fd))
  
  for (j in 1:N){ # allprobs matrix
    allprobs[ind1,j] =
      dgamma(X$step[ind1], shape = mu.g[j]^2/sigma.g[j]^2, scale = sigma.g[j]^2/mu.g[j])* #gamma
      dbeta(X$angle[ind1], shape1 = alpha[j], shape2 = beta[j])* # beta
      dsn(X$height.fd[ind1], xi = xi[j], omega = omega[j], alpha = al[j]) # skew normal
    allprobs[ind2,j] =
      dgamma(X$step[ind2], shape = mu.g[j]^2/sigma.g[j]^2, scale = sigma.g[j]^2/mu.g[j])* #gamma
      dsn(X$height.fd[ind2], xi = xi[j], omega = omega[j], alpha = al[j]) # skew normal
  }
  
  # forward algorithm to compute the log-likelihood
  l = numeric(numdays)
  # compute the daywise likelihoods seperately and sum up in the end
  for(i in 1:numdays){
    index = which(X$day == i)
    
    eta = coef[,1] + coef[,2]*X$lower_slope[index[1]] + coef[,3]*X$mountain_divide[index[1]] + coef[,4]*X$peak_ridge[index[1]] + coef[,5]*X$upper_slope[index[1]] + coef[,6]*X$valley[index[1]] +
      coef[,7]*X$temp[index[1]] + coef[,8]*sin(2*pi*X$time[index[1]]/24) + coef[,9]*cos(2*pi*X$time[index[1]]/24)
    
    # vllt statt delta die hypothetische stationary zu Tagesbeginn oder gleichverteilt
    foo = delta%*%diag(allprobs[index[1],])
    l[i] = log(sum(foo))
    phi = foo/sum(foo)
    
    for (t in 2:length(index)){
      eta = coef[,1] + coef[,2]*X$lower_slope[index[t]] + coef[,3]*X$mountain_divide[index[t]] + coef[,4]*X$peak_ridge[index[t]] + coef[,5]*X$upper_slope[index[t]] + coef[,6]*X$valley[index[t]] +
        coef[,7]*X$temp[index[t]] + coef[,8]*sin(2*pi*X$time[index[t]]/24) + coef[,9]*cos(2*pi*X$time[index[t]]/24)
      
      Gamma = diag(N)
      Gamma[!Gamma] = exp(eta) # dynamically changing Gamma-Matrix
      Gamma = Gamma/rowSums(Gamma)
      
      foo = phi%*%Gamma%*%diag(allprobs[index[t],])
      l[i] = l[i]+log(sum(foo))
      phi = foo/sum(foo)
    }
  }
  l = sum(l)
  return(-l) 
}



# Viterbi functions -------------------------------------------------------

viterbi_na_sn_cov2 = function(theta.star, X, N){
  n = nrow(X)
  days = unique(X$day)
  numdays = length(days)
  
  coef = matrix(theta.star[1:(2*(N-1)*N)], (N-1)*N, 2)
  
  # gamma distribution: Step length
  mu.g = exp(theta.star[2*(N-1)*N+1:N]) # means of gamma distributions
  sigma.g = exp(theta.star[2*(N-1)*N+N+1:N]) # sds of gamma distributions
  
  # beta distribution: Turning angle/ pi
  alpha = exp(theta.star[2*(N-1)*N+2*N+1:N]) # shape1 parameters of beta distributions
  beta = exp(theta.star[2*(N-1)*N+3*N+1:N]) # shape2 parameters of beta distributions
  
  # normal distribution: Height first difference
  xi = theta.star[2*(N-1)*N+4*N+1:N] # means of normal distributions
  omega = exp(theta.star[2*(N-1)*N+5*N+1:N]) # sds of normal distributions
  al = theta.star[2*(N-1)*N+6*N+1:N]
  
  delta = c(1, exp(theta.star[2*(N-1)*N+7*N+1:(N-1)]))
  delta = delta/sum(delta)
  
  allprobs = matrix(1, nrow(X), N)
  ind1 = which(!is.na(X$step) & !is.na(X$angle) & !is.na(X$height.fd)) # Fragen wie wir das machen --> sonst immer gar keine Information nur weil in angle Zeitreihe so viele NAs
  ind2 = which(!is.na(X$step) & is.na(X$angle) & !is.na(X$height.fd))
  
  for (j in 1:N){ # allprobs matrix
    allprobs[ind1,j] =
      dgamma(X$step[ind1], shape = mu.g[j]^2/sigma.g[j]^2, scale = sigma.g[j]^2/mu.g[j])* #gamma
      dbeta(X$angle[ind1], shape1 = alpha[j], shape2 = beta[j])* # beta
      dsn(X$height.fd[ind1], xi = xi[j], omega = omega[j], alpha = al[j]) # skew normal
    
    allprobs[ind2,j] =
      dgamma(X$step[ind2], shape = mu.g[j]^2/sigma.g[j]^2, scale = sigma.g[j]^2/mu.g[j])* #gamma
      dsn(X$height.fd[ind2], xi = xi[j], omega = omega[j], alpha = al[j]) # skew normal
  }
  
  # forward algorithm to compute the log-likelihood
  l = numeric(numdays)
  xi = matrix(0, n, ncol = N)
  # compute the daywise likelihoods seperately and sum up in the end
  for(i in 1:numdays){
    index = which(X$day == i)
    
    foo = delta * allprobs[index[1], ]
    xi[index[1], ] = foo / sum(foo)
    
    for (t in 2:length(index)){
      eta = coef[,1] + coef[,2]*X$temp[index[t]]
      Gamma = diag(N)
      Gamma[!Gamma] = exp(eta) # dynamically changing Gamma-Matrix
      Gamma = Gamma/rowSums(Gamma)
      
      foo = apply(xi[index[t - 1], ] * Gamma, 2, max) * allprobs[index[t], ]
      xi[index[t], ] = foo / sum(foo) 
    }
  }
  
  iv <- numeric(n)
  iv[n] <- which.max(xi[n, ]) 
  for (t in (n - 1):1){
    eta = coef[,1] + coef[,2]*X$temp[t]
    Gamma = diag(N)
    Gamma[!Gamma] = exp(eta) # dynamically changing Gamma-Matrix
    Gamma = Gamma/rowSums(Gamma)
    
    iv[t] <- which.max(Gamma[, iv[t + 1]] * xi[t, ]) }
  return(iv) 
}


viterbi_tod = function(theta.star, X, N){
  n = nrow(X)
  days = unique(X$day)
  numdays = length(days)
  
  coef = matrix(theta.star[1:(3*(N-1)*N)], (N-1)*N, 3)
  
  # gamma distribution: Step length
  mu.g = exp(theta.star[3*(N-1)*N+1:N]) # means of gamma distributions
  sigma.g = exp(theta.star[3*(N-1)*N+N+1:N]) # sds of gamma distributions
  
  # beta distribution: Turning angle/ pi
  alpha = exp(theta.star[3*(N-1)*N+2*N+1:N]) # shape1 parameters of beta distributions
  beta = exp(theta.star[3*(N-1)*N+3*N+1:N]) # shape2 parameters of beta distributions
  
  # normal distribution: Height first difference
  xi = theta.star[3*(N-1)*N+4*N+1:N] # means of normal distributions
  omega = exp(theta.star[3*(N-1)*N+5*N+1:N]) # sds of normal distributions
  al = theta.star[3*(N-1)*N+6*N+1:N]
  
  allprobs = matrix(1, nrow(X), N)
  ind1 = which(!is.na(X$step) & !is.na(X$angle) & !is.na(X$height.fd)) # Fragen wie wir das machen --> sonst immer gar keine Information nur weil in angle Zeitreihe so viele NAs
  ind2 = which(!is.na(X$step) & is.na(X$angle) & !is.na(X$height.fd))
  
  for (j in 1:N){ # allprobs matrix
    allprobs[ind1,j] =
      dgamma(X$step[ind1], shape = mu.g[j]^2/sigma.g[j]^2, scale = sigma.g[j]^2/mu.g[j])* #gamma
      dbeta(X$angle[ind1], shape1 = alpha[j], shape2 = beta[j])* # beta
      dsn(X$height.fd[ind1], xi = xi[j], omega = omega[j], alpha = al[j]) # skew normal
    
    allprobs[ind2,j] =
      dgamma(X$step[ind2], shape = mu.g[j]^2/sigma.g[j]^2, scale = sigma.g[j]^2/mu.g[j])* #gamma
      dsn(X$height.fd[ind2], xi = xi[j], omega = omega[j], alpha = al[j]) # skew normal
  }
  
  # forward algorithm to compute the log-likelihood
  l = numeric(numdays)
  xi = matrix(0, n, ncol = N)

  for(i in 1:numdays){
    index = which(X$day == i)
    
    eta = coef[,1] + coef[,2]*sin(2*pi*X$time[index[1]]/24) + coef[,3]*cos(2*pi*X$time[index[1]]/24)
    
    Gamma = diag(N)
    Gamma[!Gamma] = exp(eta) # dynamically changing Gamma-Matrix
    Gamma = Gamma/rowSums(Gamma)
    delta = solve(t(diag(N)-Gamma+1),rep(1,N), tol = 1e-18)
    
    # vllt statt delta die hypothetische stationary zu Tagesbeginn oder gleichverteilt
    foo = delta * allprobs[index[1], ]
    xi[index[1], ] = foo / sum(foo)
    
    for (t in 2:length(index)){
      eta = coef[,1] + coef[,2]*sin(2*pi*X$time[index[t]]/24) + coef[,3]*cos(2*pi*X$time[index[t]]/24)
      Gamma = diag(N)
      Gamma[!Gamma] = exp(eta) # dynamically changing Gamma-Matrix
      Gamma = Gamma/rowSums(Gamma)
      
      foo = apply(xi[index[t - 1], ] * Gamma, 2, max) * allprobs[index[t], ]
      xi[index[t], ] = foo / sum(foo) 
    }
  }
  iv <- numeric(n)
  iv[n] <- which.max(xi[n, ]) 
  for (t in (n - 1):1){
    eta = coef[,1] + coef[,2]*sin(2*pi*X$time[t]/24) + coef[,3]*cos(2*pi*X$time[t]/24)
    Gamma = diag(N)
    Gamma[!Gamma] = exp(eta) # dynamically changing Gamma-Matrix
    Gamma = Gamma/rowSums(Gamma)
    
    iv[t] = which.max(Gamma[, iv[t + 1]] * xi[t, ]) }
  return(iv)  
}


viterbi_tt = function(theta.star, X, N){
  n = nrow(X)
  days = unique(X$day)
  numdays = length(days)
  
  coef = matrix(theta.star[1:(4*(N-1)*N)], (N-1)*N, 4)
  
  # gamma distribution: Step length
  mu.g = exp(theta.star[4*(N-1)*N+1:N]) # means of gamma distributions
  sigma.g = exp(theta.star[4*(N-1)*N+N+1:N]) # sds of gamma distributions
  
  # beta distribution: Turning angle/ pi
  alpha = exp(theta.star[4*(N-1)*N+2*N+1:N]) # shape1 parameters of beta distributions
  beta = exp(theta.star[4*(N-1)*N+3*N+1:N]) # shape2 parameters of beta distributions
  
  # normal distribution: Height first difference
  xi = theta.star[4*(N-1)*N+4*N+1:N] # means of normal distributions
  omega = exp(theta.star[4*(N-1)*N+5*N+1:N]) # sds of normal distributions
  al = theta.star[4*(N-1)*N+6*N+1:N]
  
  delta = c(1, exp(theta.star[4*(N-1)*N+7*N+1:(N-1)]))
  delta = delta/sum(delta)
  
  allprobs = matrix(1, nrow(X), N)
  ind1 = which(!is.na(X$step) & !is.na(X$angle) & !is.na(X$height.fd)) # Fragen wie wir das machen --> sonst immer gar keine Information nur weil in angle Zeitreihe so viele NAs
  ind2 = which(!is.na(X$step) & is.na(X$angle) & !is.na(X$height.fd))
  
  for (j in 1:N){ # allprobs matrix
    allprobs[ind1,j] =
      dgamma(X$step[ind1], shape = mu.g[j]^2/sigma.g[j]^2, scale = sigma.g[j]^2/mu.g[j])* #gamma
      dbeta(X$angle[ind1], shape1 = alpha[j], shape2 = beta[j])* # beta
      dsn(X$height.fd[ind1], xi = xi[j], omega = omega[j], alpha = al[j]) # skew normal
    
    allprobs[ind2,j] =
      dgamma(X$step[ind2], shape = mu.g[j]^2/sigma.g[j]^2, scale = sigma.g[j]^2/mu.g[j])* #gamma
      dsn(X$height.fd[ind2], xi = xi[j], omega = omega[j], alpha = al[j]) # skew normal
  }
  
  # forward algorithm to compute the log-likelihood
  l = numeric(numdays)
  xi = matrix(0, n, ncol = N)
  
  for(i in 1:numdays){
    index = which(X$day == i)
    
    eta = coef[,1] + coef[,2]*sin(2*pi*X$time[index[1]]/24) + coef[,3]*cos(2*pi*X$time[index[1]]/24) + 
      coef[,4]*X$temp[index[1]]
    
    Gamma = diag(N)
    Gamma[!Gamma] = exp(eta) # dynamically changing Gamma-Matrix
    Gamma = Gamma/rowSums(Gamma)

    foo = delta * allprobs[index[1], ]
    xi[index[1], ] = foo / sum(foo)
    
    for (t in 2:length(index)){
      eta = coef[,1] + coef[,2]*sin(2*pi*X$time[index[t]]/24) + coef[,3]*cos(2*pi*X$time[index[t]]/24) + 
        coef[,4]*X$temp[index[t]]
      Gamma = diag(N)
      Gamma[!Gamma] = exp(eta) # dynamically changing Gamma-Matrix
      Gamma = Gamma/rowSums(Gamma)
      
      foo = apply(xi[index[t - 1], ] * Gamma, 2, max) * allprobs[index[t], ]
      xi[index[t], ] = foo / sum(foo) 
    }
  }
  iv <- numeric(n)
  iv[n] <- which.max(xi[n, ]) 
  for (t in (n - 1):1){
    eta = coef[,1] + coef[,2]*sin(2*pi*X$time[t]/24) + coef[,3]*cos(2*pi*X$time[t]/24) + 
      coef[,4]*X$temp[t]
    Gamma = diag(N)
    Gamma[!Gamma] = exp(eta) # dynamically changing Gamma-Matrix
    Gamma = Gamma/rowSums(Gamma)
    
    iv[t] = which.max(Gamma[, iv[t + 1]] * xi[t, ]) }
  return(iv) 
}


viterbi_landform = function(theta.star, X, N){
  n = nrow(X)
  days = unique(X$day)
  numdays = length(days)
  
  coef = matrix(theta.star[1:(6*(N-1)*N)], (N-1)*N, 6)
  
  # gamma distribution: Step length
  mu.g = exp(theta.star[6*(N-1)*N+1:N]) # means of gamma distributions
  sigma.g = exp(theta.star[6*(N-1)*N+N+1:N]) # sds of gamma distributions
  
  # beta distribution: Turning angle/ pi
  alpha = exp(theta.star[6*(N-1)*N+2*N+1:N]) # shape1 parameters of beta distributions
  beta = exp(theta.star[6*(N-1)*N+3*N+1:N]) # shape2 parameters of beta distributions
  
  # skew normal distribution: Height first difference
  xi = theta.star[6*(N-1)*N+4*N+1:N] # means of normal distributions
  omega = exp(theta.star[6*(N-1)*N+5*N+1:N]) # sds of normal distributions
  al = theta.star[6*(N-1)*N+6*N+1:N]
  
  delta = c(1, exp(theta.star[6*(N-1)*N+7*N+1:(N-1)]))
  delta = delta/sum(delta)
  
  allprobs = matrix(1, nrow(X), N)
  ind1 = which(!is.na(X$step) & !is.na(X$angle) & !is.na(X$height.fd)) # Fragen wie wir das machen --> sonst immer gar keine Information nur weil in angle Zeitreihe so viele NAs
  ind2 = which(!is.na(X$step) & is.na(X$angle) & !is.na(X$height.fd))
  
  for (j in 1:N){ # allprobs matrix
    allprobs[ind1,j] =
      dgamma(X$step[ind1], shape = mu.g[j]^2/sigma.g[j]^2, scale = sigma.g[j]^2/mu.g[j])* #gamma
      dbeta(X$angle[ind1], shape1 = alpha[j], shape2 = beta[j])* # beta
      dsn(X$height.fd[ind1], xi = xi[j], omega = omega[j], alpha = al[j]) # skew normal
    
    allprobs[ind2,j] =
      dgamma(X$step[ind2], shape = mu.g[j]^2/sigma.g[j]^2, scale = sigma.g[j]^2/mu.g[j])* #gamma
      dsn(X$height.fd[ind2], xi = xi[j], omega = omega[j], alpha = al[j]) # skew normal
  }
  
  xi = matrix(0, n, ncol = N)
  
  for(i in 1:numdays){
    index = which(X$day == i)
    
    eta = coef[,1] + coef[,2]*X$lower_slope[index[1]] + coef[,3]*X$mountain_divide[index[1]] + 
      coef[,4]*X$peak_ridge[index[1]] + coef[,5]*X$upper_slope[index[1]] + 
      coef[,6]*X$valley[index[1]]
    
    Gamma = diag(N)
    Gamma[!Gamma] = exp(eta) # dynamically changing Gamma-Matrix
    Gamma = Gamma/rowSums(Gamma)

    # vllt statt delta die hypothetische stationary zu Tagesbeginn oder gleichverteilt
    foo = delta * allprobs[index[1], ]
    xi[index[1], ] = foo / sum(foo)
    
    for (t in 2:length(index)){
      eta = coef[,1] + coef[,2]*X$lower_slope[index[t]] + coef[,3]*X$mountain_divide[index[t]] + 
        coef[,4]*X$peak_ridge[index[t]] + coef[,5]*X$upper_slope[index[t]] + 
        coef[,6]*X$valley[index[t]]
      
      Gamma = diag(N)
      Gamma[!Gamma] = exp(eta) # dynamically changing Gamma-Matrix
      Gamma = Gamma/rowSums(Gamma)
      
      foo = apply(xi[index[t - 1], ] * Gamma, 2, max) * allprobs[index[t], ]
      xi[index[t], ] = foo / sum(foo) 
    }
  }
  iv <- numeric(n)
  iv[n] <- which.max(xi[n, ]) 
  for (t in (n - 1):1){
    eta = coef[,1] + coef[,2]*X$lower_slope[t] + coef[,3]*X$mountain_divide[t] + 
      coef[,4]*X$peak_ridge[t] + coef[,5]*X$upper_slope[t] + 
      coef[,6]*X$valley[t]
    
    Gamma = diag(N)
    Gamma[!Gamma] = exp(eta) # dynamically changing Gamma-Matrix
    Gamma = Gamma/rowSums(Gamma)
    
    iv[t] = which.max(Gamma[, iv[t + 1]] * xi[t, ]) }
  return(iv)
}


viterbi_ttl = function(theta.star, X, N){
  n = nrow(X)
  numdays = max(X$day)
  
  coef = matrix(theta.star[1:(9*(N-1)*N)], (N-1)*N, 9)
  
  # gamma distribution: Step length
  mu.g = exp(theta.star[9*(N-1)*N+1:N]) # means of gamma distributions
  sigma.g = exp(theta.star[9*(N-1)*N+N+1:N]) # sds of gamma distributions
  
  # beta distribution: Turning angle/ pi
  alpha = exp(theta.star[9*(N-1)*N+2*N+1:N]) # shape1 parameters of beta distributions
  beta = exp(theta.star[9*(N-1)*N+3*N+1:N]) # shape2 parameters of beta distributions
  
  # skew normal distribution: Height first difference
  xi = theta.star[9*(N-1)*N+4*N+1:N] # means of normal distributions
  omega = exp(theta.star[9*(N-1)*N+5*N+1:N]) # sds of normal distributions
  al = theta.star[9*(N-1)*N+6*N+1:N]
  
  delta = c(1, exp(theta.star[9*(N-1)*N+7*N+1:(N-1)]))
  delta = delta/sum(delta)
  
  allprobs = matrix(1, nrow(X), N)
  ind1 = which(!is.na(X$step) & !is.na(X$angle) & !is.na(X$height.fd)) # Fragen wie wir das machen --> sonst immer gar keine Information nur weil in angle Zeitreihe so viele NAs
  ind2 = which(!is.na(X$step) & is.na(X$angle) & !is.na(X$height.fd))
  
  for (j in 1:N){ # allprobs matrix
    allprobs[ind1,j] =
      dgamma(X$step[ind1], shape = mu.g[j]^2/sigma.g[j]^2, scale = sigma.g[j]^2/mu.g[j])* #gamma
      dbeta(X$angle[ind1], shape1 = alpha[j], shape2 = beta[j])* # beta
      dsn(X$height.fd[ind1], xi = xi[j], omega = omega[j], alpha = al[j]) # skew normal
    allprobs[ind2,j] =
      dgamma(X$step[ind2], shape = mu.g[j]^2/sigma.g[j]^2, scale = sigma.g[j]^2/mu.g[j])* #gamma
      dsn(X$height.fd[ind2], xi = xi[j], omega = omega[j], alpha = al[j]) # skew normal
  }
  
  xi = matrix(0, n, ncol = N)
  
  for(i in 1:numdays){
    index = which(X$day == i)
    
    eta = coef[,1] + coef[,2]*X$lower_slope[index[1]] + coef[,3]*X$mountain_divide[index[1]] + coef[,4]*X$peak_ridge[index[1]] + coef[,5]*X$upper_slope[index[1]] + coef[,6]*X$valley[index[1]] +
      coef[,7]*X$temp[index[1]] + coef[,8]*sin(2*pi*X$time[index[1]]/24) + coef[,9]*cos(2*pi*X$time[index[1]]/24)
    
    
    Gamma = diag(N)
    Gamma[!Gamma] = exp(eta) # dynamically changing Gamma-Matrix
    Gamma = Gamma/rowSums(Gamma)
    
    # vllt statt delta die hypothetische stationary zu Tagesbeginn oder gleichverteilt
    foo = delta * allprobs[index[1], ]
    xi[index[1], ] = foo / sum(foo)
    
    for (t in 2:length(index)){
      eta = coef[,1] + coef[,2]*X$lower_slope[index[t]] + coef[,3]*X$mountain_divide[index[t]] + coef[,4]*X$peak_ridge[index[t]] + coef[,5]*X$upper_slope[index[t]] + coef[,6]*X$valley[index[t]] +
        coef[,7]*X$temp[index[t]] + coef[,8]*sin(2*pi*X$time[index[t]]/24) + coef[,9]*cos(2*pi*X$time[index[t]]/24)
      
      Gamma = diag(N)
      Gamma[!Gamma] = exp(eta) # dynamically changing Gamma-Matrix
      Gamma = Gamma/rowSums(Gamma)
      
      foo = apply(xi[index[t - 1], ] * Gamma, 2, max) * allprobs[index[t], ]
      xi[index[t], ] = foo / sum(foo) 
    }
  }
  iv <- numeric(n)
  iv[n] <- which.max(xi[n, ]) 
  for (t in (n - 1):1){
    eta = coef[,1] + coef[,2]*X$lower_slope[t] + coef[,3]*X$mountain_divide[t] + coef[,4]*X$peak_ridge[t] + coef[,5]*X$upper_slope[t] + coef[,6]*X$valley[t] +
      coef[,7]*X$temp[t] + coef[,8]*sin(2*pi*X$time[t]/24) + coef[,9]*cos(2*pi*X$time[t]/24)
    
    
    Gamma = diag(N)
    Gamma[!Gamma] = exp(eta) # dynamically changing Gamma-Matrix
    Gamma = Gamma/rowSums(Gamma)
    
    iv[t] = which.max(Gamma[, iv[t + 1]] * xi[t, ]) }
  return(iv) 
}


viterbi_na_sn_cov3 = function(theta.star, X, N){
  n = nrow(X)
  days = unique(X$day)
  numdays = length(days)
  
  coef = matrix(theta.star[1:(2*(N-1)*N)], (N-1)*N, 2)
  
  # gamma distribution: Step length
  mu.g = exp(theta.star[2*(N-1)*N+1:N]) # means of gamma distributions
  sigma.g = exp(theta.star[2*(N-1)*N+N+1:N]) # sds of gamma distributions
  
  # beta distribution: Turning angle/ pi
  alpha = exp(theta.star[2*(N-1)*N+2*N+1:N]) # shape1 parameters of beta distributions
  beta = exp(theta.star[2*(N-1)*N+3*N+1:N]) # shape2 parameters of beta distributions
  
  # normal distribution: Height first difference
  xi = theta.star[2*(N-1)*N+4*N+1:N] # means of normal distributions
  omega = exp(theta.star[2*(N-1)*N+5*N+1:N]) # sds of normal distributions
  al = theta.star[2*(N-1)*N+6*N+1:N]
  
  delta = c(1, exp(theta.star[2*(N-1)*N+7*N+1:(N-1)]))
  delta = delta/sum(delta)
  
  allprobs = matrix(1, nrow(X), N)
  ind1 = which(!is.na(X$step) & !is.na(X$angle) & !is.na(X$height.fd)) # Fragen wie wir das machen --> sonst immer gar keine Information nur weil in angle Zeitreihe so viele NAs
  ind2 = which(!is.na(X$step) & is.na(X$angle) & !is.na(X$height.fd))
  
  for (j in 1:N){ # allprobs matrix
    allprobs[ind1,j] =
      dgamma(X$step[ind1], shape = mu.g[j]^2/sigma.g[j]^2, scale = sigma.g[j]^2/mu.g[j])* #gamma
      dbeta(X$angle[ind1], shape1 = alpha[j], shape2 = beta[j])* # beta
      dsn(X$height.fd[ind1], xi = xi[j], omega = omega[j], alpha = al[j]) # skew normal
    
    allprobs[ind2,j] =
      dgamma(X$step[ind2], shape = mu.g[j]^2/sigma.g[j]^2, scale = sigma.g[j]^2/mu.g[j])* #gamma
      dsn(X$height.fd[ind2], xi = xi[j], omega = omega[j], alpha = al[j]) # skew normal
  }
  
  # forward algorithm to compute the log-likelihood
  l = numeric(numdays)
  xi = matrix(0, n, ncol = N)
  # compute the daywise likelihoods seperately and sum up in the end
  for(i in 1:numdays){
    index = which(X$day == i)
    
    foo = delta * allprobs[index[1], ]
    xi[index[1], ] = foo / sum(foo)
    
    for (t in 2:length(index)){
      eta = coef[,1] + coef[,2]*X$temp[index[t]]
      Gamma = diag(N)
      Gamma[!Gamma] = exp(eta) # dynamically changing Gamma-Matrix
      Gamma = Gamma/rowSums(Gamma)
      
      foo = apply(xi[index[t - 1], ] * Gamma, 2, max) * allprobs[index[t], ]
      xi[index[t], ] = foo / sum(foo) 
    }
  }
  
  iv <- numeric(n)
  iv[n] <- which.max(xi[n, ]) 
  for (t in (n - 1):1){
    eta = coef[,1] + coef[,2]*X$elevation[t]
    Gamma = diag(N)
    Gamma[!Gamma] = exp(eta) # dynamically changing Gamma-Matrix
    Gamma = Gamma/rowSums(Gamma)
    
    iv[t] <- which.max(Gamma[, iv[t + 1]] * xi[t, ]) }
  return(iv) 
}


viterbi_na_sn_cov = function(theta.star, X, N){
  n = nrow(X)
  
  coef = matrix(theta.star[1:(2*(N-1)*N)], (N-1)*N, 2)
  
  # gamma distribution: Step length
  mu.g = exp(theta.star[2*(N-1)*N+1:N]) # means of gamma distributions
  sigma.g = exp(theta.star[2*(N-1)*N+N+1:N]) # sds of gamma distributions
  
  # beta distribution: Turning angle/ pi
  alpha = exp(theta.star[2*(N-1)*N+2*N+1:N]) # shape1 parameters of beta distributions
  beta = exp(theta.star[2*(N-1)*N+3*N+1:N]) # shape2 parameters of beta distributions
  
  # normal distribution: Height first difference
  xi = theta.star[2*(N-1)*N+4*N+1:N] # means of normal distributions
  omega = exp(theta.star[2*(N-1)*N+5*N+1:N]) # sds of normal distributions
  al = theta.star[2*(N-1)*N+6*N+1:N]
  
  delta = c(1, exp(theta.star[2*(N-1)*N+7*N+1:(N-1)]))
  delta = delta/sum(delta)
  
  allprobs = matrix(1, nrow(X), N)
  ind1 = which(!is.na(X$step) & !is.na(X$angle) & !is.na(X$height.fd)) # Fragen wie wir das machen --> sonst immer gar keine Information nur weil in angle Zeitreihe so viele NAs
  ind2 = which(!is.na(X$step) & is.na(X$angle) & !is.na(X$height.fd))
  
  for (j in 1:N){ # allprobs matrix
    allprobs[ind1,j] =
      dgamma(X$step[ind1], shape = mu.g[j]^2/sigma.g[j]^2, scale = sigma.g[j]^2/mu.g[j])* #gamma
      dbeta(X$angle[ind1], shape1 = alpha[j], shape2 = beta[j])* # beta
      dsn(X$height.fd[ind1], xi = xi[j], omega = omega[j], alpha = al[j]) # skew normal
    
    allprobs[ind2,j] =
      dgamma(X$step[ind2], shape = mu.g[j]^2/sigma.g[j]^2, scale = sigma.g[j]^2/mu.g[j])* #gamma
      dsn(X$height.fd[ind2], xi = xi[j], omega = omega[j], alpha = al[j]) # skew normal
  }

  xi = matrix(0, n, ncol = N) 
  foo = delta * allprobs[1, ]
  xi[1, ] = foo / sum(foo)
  for (t in 2:n){
    eta = coef[,1] + coef[,2]*X$temp[t]
    Gamma = diag(N)
    Gamma[!Gamma] = exp(eta) # dynamically changing Gamma-Matrix
    Gamma = Gamma/rowSums(Gamma)
    
    foo = apply(xi[t - 1, ] * Gamma, 2, max) * allprobs[t, ]
    xi[t, ] = foo / sum(foo) 
  }
  
  iv <- numeric(n)
  iv[n] <- which.max(xi[n, ]) 
  for (t in (n - 1):1){
    iv[t] <- which.max(Gamma[, iv[t + 1]] * xi[t, ]) }
  return(iv) 
}


# Functions to get transprobs and delta -----------------------------------

solve_gamma_na_sn_cov = function(theta.star, temp, N){
  coef = matrix(theta.star[1:(2*(N-1)*N)], (N-1)*N, 2)
  delta = matrix(data = NA, nrow = length(temp), ncol = N)
  
  for (i in 1:length(temp)){
    eta = coef[,1] + coef[,2]*temp[i]
    Gamma = diag(N)
    Gamma[!Gamma] = exp(eta) # dynamically changing Gamma-Matrix
    Gamma = Gamma/rowSums(Gamma)
    
    delta[i,] = solve(t(diag(N)-Gamma+1),rep(1,N), tol = 1e-18)
  }
  return(delta)
}


solve_gamma_tod = function(theta.star, tod, N){
  coef = matrix(theta.star[1:(3*(N-1)*N)], (N-1)*N, 3)
  delta = matrix(data = NA, nrow = length(tod), ncol = N)
  
  for (i in 1:length(tod)){
    eta = coef[,1] + coef[,2]*sin(2*pi*tod[i]/24) + coef[,3]*cos(2*pi*tod[i]/24)
    Gamma = diag(N)
    Gamma[!Gamma] = exp(eta) # dynamically changing Gamma-Matrix
    Gamma = Gamma/rowSums(Gamma)
    
    delta[i,] = solve(t(diag(N)-Gamma+1),rep(1,N), tol = 1e-18)
  }
  return(delta)
}

solve_gamma_tt1 = function(theta.star, tod, tempmean, N){
  coef = matrix(theta.star[1:(4*(N-1)*N)], (N-1)*N, 4)
  delta = matrix(data = NA, nrow = length(tod), ncol = N)
  
  for (i in 1:length(tod)){
    eta = coef[,1] + coef[,2]*sin(2*pi*tod[i]/24) + coef[,3]*cos(2*pi*tod[i]/24) + coef[,4]*tempmean
    Gamma = diag(N)
    Gamma[!Gamma] = exp(eta) # dynamically changing Gamma-Matrix
    Gamma = Gamma/rowSums(Gamma)
    
    delta[i,] = solve(t(diag(N)-Gamma+1),rep(1,N), tol = 1e-30)
  }
  return(delta)
}

solve_gamma_tt2 = function(theta.star, temp, todmean, N){
  coef = matrix(theta.star[1:(4*(N-1)*N)], (N-1)*N, 4)
  delta = matrix(data = NA, nrow = length(temp), ncol = N)
  
  for (i in 1:length(temp)){
    eta = coef[,1] + coef[,2]*sin(2*pi*todmean/24) + coef[,3]*cos(2*pi*todmean/24) + coef[,4]*temp[i]
    Gamma = diag(N)
    Gamma[!Gamma] = exp(eta) # dynamically changing Gamma-Matrix
    Gamma = Gamma/rowSums(Gamma)
    
    delta[i,] = solve(t(diag(N)-Gamma+1),rep(1,N), tol = 1e-30)
  }
  return(delta)
}


solve_gamma_landform = function(theta.star, N){
  landform = c("C", "LS", "MD", "PR", "US", "V")
  coef = matrix(theta.star[1:(6*(N-1)*N)], (N-1)*N, 6)
  delta = matrix(data = NA, nrow = length(landform), ncol = N)
  
  eta = coef[,1] 
  Gamma = diag(N)
  Gamma[!Gamma] = exp(eta) # dynamically changing Gamma-Matrix
  Gamma = Gamma/rowSums(Gamma)
  
  delta[1,] = solve(t(diag(N)-Gamma+1),rep(1,N), tol = 1e-18)
  
  for (i in 2:length(landform)){
    eta = coef[,1] + coef[,i]
    Gamma = diag(N)
    Gamma[!Gamma] = exp(eta) # dynamically changing Gamma-Matrix
    Gamma = Gamma/rowSums(Gamma)
    
    delta[i,] = solve(t(diag(N)-Gamma+1),rep(1,N), tol = 1e-18)
  }
  return(list(landform = as.factor(landform), delta = delta))
}


solve_gamma_ttl1 = function(theta.star, tod, tempmean, N){
  coef = matrix(theta.star[1:(9*(N-1)*N)], (N-1)*N, 9)
  delta = matrix(data = NA, nrow = length(tod), ncol = N*6)
  
  for (i in 1:length(tod)){
    eta = coef[,1] + 
      coef[,7]*tempmean + coef[,8]*sin(2*pi*tod[i]/24) + coef[,9]*cos(2*pi*tod[i]/24)
    
    Gamma = diag(N)
    Gamma[!Gamma] = exp(eta) # dynamically changing Gamma-Matrix
    Gamma = Gamma/rowSums(Gamma)
    
    delta[i,1:4] = solve(t(diag(N)-Gamma+1),rep(1,N), tol = 1e-30)
    
    for (j in 2:6){
      eta = coef[,1] + coef[,j] +
        coef[,7]*tempmean + coef[,8]*sin(2*pi*tod[i]/24) + coef[,9]*cos(2*pi*tod[i]/24)
      
      Gamma = diag(N)
      Gamma[!Gamma] = exp(eta) # dynamically changing Gamma-Matrix
      Gamma = Gamma/rowSums(Gamma)
      
      delta[i,(j-1)*4+1:4] = solve(t(diag(N)-Gamma+1),rep(1,N), tol = 1e-30)
    }
  }
  return(delta)
}

solve_gamma_ttl2 = function(theta.star, temp, todmean, N){
  coef = matrix(theta.star[1:(9*(N-1)*N)], (N-1)*N, 9)
  delta = matrix(data = NA, nrow = length(temp), ncol = N*6)
  
  for (i in 1:length(temp)){
    eta = coef[,1] + 
      coef[,7]*temp[i] + coef[,8]*sin(2*pi*todmean/24) + coef[,9]*cos(2*pi*todmean/24)
    
    Gamma = diag(N)
    Gamma[!Gamma] = exp(eta) # dynamically changing Gamma-Matrix
    Gamma = Gamma/rowSums(Gamma)
    
    delta[i,1:4] = solve(t(diag(N)-Gamma+1),rep(1,N), tol = 1e-30)
    
    for (j in 2:6){
      eta = coef[,1] + coef[,j] +
      coef[,7]*temp[i] + coef[,8]*sin(2*pi*todmean/24) + coef[,9]*cos(2*pi*todmean/24)
      
      Gamma = diag(N)
      Gamma[!Gamma] = exp(eta) # dynamically changing Gamma-Matrix
      Gamma = Gamma/rowSums(Gamma)
      
      delta[i,(j-1)*4+1:4] = solve(t(diag(N)-Gamma+1),rep(1,N), tol = 1e-30)
    }
  }
  return(delta)
}


get_transprobs = function(theta.star, temp){
  N = 4
  coef = matrix(theta.star[1:(2*(N-1)*N)], (N-1)*N, 2)
  transprobs = matrix(data = NA, nrow = length(temp), ncol = N^2)
  
  for (i in 1:length(temp)){
    eta = coef[,1] + coef[,2]*temp[i]
    Gamma = diag(N)
    Gamma[!Gamma] = exp(eta) # dynamically changing Gamma-Matrix
    Gamma = Gamma/rowSums(Gamma)
    
    transprobs[i,] = c(Gamma[1,], Gamma[2,], Gamma[3,], Gamma[4,])
  }
  transprobs = as.data.frame(transprobs)
  colnames(transprobs) = c("1 -> 1","1 -> 2", "1 -> 3", "1 -> 4",
                          "2 -> 1", "2 -> 2", "2 -> 3", "2 -> 4",
                          "3 -> 1", "3 -> 2", "3 -> 3", "3 -> 4",
                          "4 -> 1", "4 -> 2", "4 -> 3", "4 -> 4")
  return(transprobs)
}


get_transprobs_tod = function(theta.star, tod){
  N = 4
  coef = matrix(theta.star[1:(3*(N-1)*N)], (N-1)*N, 3)
  transprobs = matrix(data = NA, nrow = length(tod), ncol = N^2)
  
  for (i in 1:length(tod)){
    eta = coef[,1] + coef[,2]*sin(2*pi*tod[i]/24) + coef[,3]*cos(2*pi*tod[i]/24)
    Gamma = diag(N)
    Gamma[!Gamma] = exp(eta) # dynamically changing Gamma-Matrix
    Gamma = Gamma/rowSums(Gamma)
    
    transprobs[i,] = c(Gamma[1,], Gamma[2,], Gamma[3,], Gamma[4,])
  }
  transprobs = as.data.frame(transprobs)
  colnames(transprobs) = c("1 -> 1","1 -> 2", "1 -> 3", "1 -> 4",
                           "2 -> 1", "2 -> 2", "2 -> 3", "2 -> 4",
                           "3 -> 1", "3 -> 2", "3 -> 3", "3 -> 4",
                           "4 -> 1", "4 -> 2", "4 -> 3", "4 -> 4")
  return(transprobs)
}

get_transprobs_tt1 = function(theta.star, tod, tempmean){
  N = 4
  coef = matrix(theta.star[1:(4*(N-1)*N)], (N-1)*N, 4)
  transprobs = matrix(data = NA, nrow = length(tod), ncol = N^2)
  
  for (i in 1:length(tod)){
    eta = coef[,1] + coef[,2]*sin(2*pi*tod[i]/24) + coef[,3]*cos(2*pi*tod[i]/24) + coef[,4]*tempmean
    Gamma = diag(N)
    Gamma[!Gamma] = exp(eta) # dynamically changing Gamma-Matrix
    Gamma = Gamma/rowSums(Gamma)
    
    transprobs[i,] = c(Gamma[1,], Gamma[2,], Gamma[3,], Gamma[4,])
  }
  transprobs = as.data.frame(transprobs)
  colnames(transprobs) = c("1 -> 1","1 -> 2", "1 -> 3", "1 -> 4",
                           "2 -> 1", "2 -> 2", "2 -> 3", "2 -> 4",
                           "3 -> 1", "3 -> 2", "3 -> 3", "3 -> 4",
                           "4 -> 1", "4 -> 2", "4 -> 3", "4 -> 4")
  return(transprobs)
}

get_transprobs_tt2 = function(theta.star, temp, todmean){
  N = 4
  coef = matrix(theta.star[1:(4*(N-1)*N)], (N-1)*N, 4)
  transprobs = matrix(data = NA, nrow = length(temp), ncol = N^2)
  
  for (i in 1:length(temp)){
    eta = coef[,1] + coef[,2]*sin(2*pi*todmean/24) + coef[,3]*cos(2*pi*todmean/24) + coef[,4]*temp[i]
    Gamma = diag(N)
    Gamma[!Gamma] = exp(eta) # dynamically changing Gamma-Matrix
    Gamma = Gamma/rowSums(Gamma)
    
    transprobs[i,] = c(Gamma[1,], Gamma[2,], Gamma[3,], Gamma[4,])
  }
  transprobs = as.data.frame(transprobs)
  colnames(transprobs) = c("1 -> 1","1 -> 2", "1 -> 3", "1 -> 4",
                           "2 -> 1", "2 -> 2", "2 -> 3", "2 -> 4",
                           "3 -> 1", "3 -> 2", "3 -> 3", "3 -> 4",
                           "4 -> 1", "4 -> 2", "4 -> 3", "4 -> 4")
  return(transprobs)
}


get_transprobs_landform = function(theta.star){
  N = 4
  landform = c("C", "LS", "MD", "PR", "US", "V")
  coef = matrix(theta.star[1:(6*(N-1)*N)], (N-1)*N, 6)
  transprobs = matrix(data = NA, nrow = length(landform), ncol = N^2)
  
  eta = coef[,1]
  Gamma = diag(N)
  Gamma[!Gamma] = exp(eta) # dynamically changing Gamma-Matrix
  Gamma = Gamma/rowSums(Gamma)
  transprobs[1,] = c(Gamma[1,], Gamma[2,], Gamma[3,], Gamma[4,])
  
  for (i in 2:length(landform)){
    eta = coef[,1] + coef[,i]
    Gamma = diag(N)
    Gamma[!Gamma] = exp(eta) # dynamically changing Gamma-Matrix
    Gamma = Gamma/rowSums(Gamma)
    
    transprobs[i,] = c(Gamma[1,], Gamma[2,], Gamma[3,], Gamma[4,])
  }
  transprobs = as.data.frame(transprobs)
  colnames(transprobs) = c("1 -> 1","1 -> 2", "1 -> 3", "1 -> 4",
                           "2 -> 1", "2 -> 2", "2 -> 3", "2 -> 4",
                           "3 -> 1", "3 -> 2", "3 -> 3", "3 -> 4",
                           "4 -> 1", "4 -> 2", "4 -> 3", "4 -> 4")
  return(list(landform = as.factor(landform), transprobs = transprobs))
}


get_transprobs_ttl1 = function(theta.star, tod, tempmean){
  N = 4
  coef = matrix(theta.star[1:(9*(N-1)*N)], (N-1)*N, 9)
  transprobs = matrix(data = NA, nrow = 6*length(tod), ncol = N^2)
  
  for (i in 1:length(tod)){
    eta = coef[,1] + 
      coef[,7]*tempmean + coef[,8]*sin(2*pi*tod[i]/24) + coef[,9]*cos(2*pi*tod[i]/24)    
    Gamma = diag(N)
    Gamma[!Gamma] = exp(eta) # dynamically changing Gamma-Matrix
    Gamma = Gamma/rowSums(Gamma)
    
    transprobs[(i-1)*6+1,] = c(Gamma[1,], Gamma[2,], Gamma[3,], Gamma[4,])
    
    for (j in 2:6){
      eta = coef[,1] + coef[,j] +
        coef[,7]*tempmean + coef[,8]*sin(2*pi*tod[i]/24) + coef[,9]*cos(2*pi*tod[i]/24)
        Gamma = diag(N)
        Gamma[!Gamma] = exp(eta) # dynamically changing Gamma-Matrix
        Gamma = Gamma/rowSums(Gamma)
        
        transprobs[(i-1)*6+j,] = c(Gamma[1,], Gamma[2,], Gamma[3,], Gamma[4,])
    }
  }
  transprobs = as.data.frame(transprobs)
  colnames(transprobs) = c("1 -> 1","1 -> 2", "1 -> 3", "1 -> 4",
                           "2 -> 1", "2 -> 2", "2 -> 3", "2 -> 4",
                           "3 -> 1", "3 -> 2", "3 -> 3", "3 -> 4",
                           "4 -> 1", "4 -> 2", "4 -> 3", "4 -> 4")
  return(transprobs)
}



viterbi_na_sn = function(theta.star, X, N){
  n = nrow(X)
  
  Gamma = diag(N)
  Gamma[!Gamma] = exp(theta.star[1:((N-1)*N)])
  Gamma = Gamma/rowSums(Gamma)
  delta = solve(t(diag(N)-Gamma+1),rep(1,N), tol = 1e-18) # stationary, smaller tolerance to avoid numerical problems
  
  # gamma distribution: Step length
  mu.g = exp(theta.star[(N-1)*N+1:N]) # means of gamma distributions
  sigma.g = exp(theta.star[(N-1)*N+N+1:N]) # sds of gamma distributions
  
  # beta distribution: Turning angle/ pi
  alpha = exp(theta.star[(N-1)*N+2*N+1:N]) # shape1 parameters of beta distributions
  beta = exp(theta.star[(N-1)*N+3*N+1:N]) # shape2 parameters of beta distributions
  
  # normal distribution: Height first difference
  xi = theta.star[(N-1)*N+4*N+1:N] # means of normal distributions
  omega = exp(theta.star[(N-1)*N+5*N+1:N]) # sds of normal distributions
  al = theta.star[(N-1)*N+6*N+1:N]
  
  allprobs = matrix(1, nrow(X), N)
  ind1 = which(!is.na(X$step) & !is.na(X$angle) & !is.na(X$height.fd)) # Fragen wie wir das machen --> sonst immer gar keine Information nur weil in angle Zeitreihe so viele NAs
  ind2 = which(!is.na(X$step) & is.na(X$angle) & !is.na(X$height.fd))
  
  for (j in 1:N){ # allprobs matrix
    allprobs[ind1,j] =
      dgamma(X$step[ind1], shape = mu.g[j]^2/sigma.g[j]^2, scale = sigma.g[j]^2/mu.g[j])* #gamma
      dbeta(X$angle[ind1], shape1 = alpha[j], shape2 = beta[j])* # beta
      dsn(X$height.fd[ind1], xi = xi[j], omega = omega[j], alpha = al[j]) # skew normal
    
    allprobs[ind2,j] =
      dgamma(X$step[ind2], shape = mu.g[j]^2/sigma.g[j]^2, scale = sigma.g[j]^2/mu.g[j])* #gamma
      dsn(X$height.fd[ind2], xi = xi[j], omega = omega[j], alpha = al[j]) # skew normal
  }
  
  xi = matrix(0, n, ncol = N) 
  foo = delta * allprobs[1, ]
  xi[1, ] = foo / sum(foo)
  for (t in 2:n){
    foo = apply(xi[t - 1, ] * Gamma, 2, max) * allprobs[t, ]
    xi[t, ] = foo / sum(foo) 
  }
  iv <- numeric(n)
  iv[n] <- which.max(xi[n, ]) 
  for (t in (n - 1):1){
    iv[t] <- which.max(Gamma[, iv[t + 1]] * xi[t, ]) }
  return(iv) 
}


mllk_cov = function(theta.star, X, N){
  # avoid zero beta
  X$angle[which(X$angle == 0)] = runif(length(X$angle[which(X$angle == 0)]), 0, 0.03)
  
  # get betas
  coef = matrix(theta.star[1:(2*(N-1)*N)], (N-1)*N, 2)
  
  # gamma distribution: Step length
  mu.g = exp(theta.star[2*(N-1)*N+1:N]) # means of gamma distributions
  sigma.g = exp(theta.star[2*(N-1)*N+N+1:N]) # sds of gamma distributions
  
  # beta distribution: Turning angle/ pi
  alpha = exp(theta.star[2*(N-1)*N+2*N+1:N]) # shape1 parameters of beta distributions
  beta = exp(theta.star[2*(N-1)*N+3*N+1:N]) # shape2 parameters of beta distributions
  
  # normal distribution: Height first difference
  mu = theta.star[2*(N-1)*N+4*N+1:N] # means of normal distributions
  sigma = exp(theta.star[2*(N-1)*N+5*N+1:N]) # sds of normal distributions
  
  delta = c(1, exp(theta.star[2*(N-1)*N+6*N+1:(N-1)])) # initial distribution
  delta = delta/sum(delta)
  
  allprobs = matrix(1, nrow(X), N)
  ind = which(!is.na(X$step) & !is.na(X$angle) & !is.na(X$height.fd)) # Fragen wie wir das machen --> sonst immer gar keine Information nur weil in angle Zeitreihe so viele NAs
  
  for (j in 1:N){ # allprobs matrix
    allprobs[ind,j] =
      dgamma(X$step[ind], shape = mu.g[j]^2/sigma.g[j]^2, scale = sigma.g[j]^2/mu.g[j])* #gamma
      dbeta(X$angle[ind], shape1 = alpha[j], shape2 = beta[j])* # beta
      dnorm(X$height.fd[ind], mean = mu[j], sd = sigma[j]) # normal
  }
  
  # forward algorithm to compute the log-likelihood
  foo = delta%*%diag(allprobs[1,])
  l = log(sum(foo))
  phi = foo/sum(foo)
  for (t in 2:nrow(X)){
    eta = coef[,1] + coef[,2]*X$temp[t]
    Gamma = diag(N)
    Gamma[!Gamma] = exp(eta) # dynamically changing Gamma-Matrix
    Gamma = Gamma/rowSums(Gamma)
    
    foo = phi%*%Gamma%*%diag(allprobs[t,])
    l = l+log(sum(foo))
    phi = foo/sum(foo)
  }
  
  return(-l) 
}



get_probs = function(theta.star, X, N){
  Gamma = diag(N)
  Gamma[!Gamma] = exp(theta.star[1:((N-1)*N)])
  Gamma = Gamma/rowSums(Gamma)
  delta = solve(t(diag(N)-Gamma+1),rep(1,N), tol = 1e-20) # stationary, smaller tolerance to avoid numerical problems
  
  # gamma distribution: Step length
  mu.g = exp(theta.star[(N-1)*N+1:N]) # means of gamma distributions
  sigma.g = exp(theta.star[(N-1)*N+N+1:N]) # sds of gamma distributions
  
  # beta distribution: Turning angle/ pi
  alpha = exp(theta.star[(N-1)*N+2*N+1:N]) # shape1 parameters of beta distributions
  beta = exp(theta.star[(N-1)*N+3*N+1:N]) # shape2 parameters of beta distributions
  p.b = plogis(theta.star[(N-1)*N+4*N+1:N])
  
  # normal distribution: Height first difference
  mu = theta.star[(N-1)*N+5*N+1:N] # means of normal distributions
  sigma = exp(theta.star[(N-1)*N+6*N+1:N]) # sds of normal distributions
  
  allprobs = matrix(1, nrow(X), N)
  ind = which(!is.na(X$step) & !is.na(X$angle) & !is.na(X$height.fd)) # Fragen wie wir das machen --> sonst immer gar keine Information nur weil in angle Zeitreihe so viele NAs
  
  for (j in 1:N){ # allprobs matrix
    allprobs[ind,j] =
      dgamma(X$step[ind], shape = mu.g[j]^2/sigma.g[j]^2, scale = sigma.g[j]^2/mu.g[j])* #gamma
      zbeta(X$angle[ind], shape1 = alpha[j], shape2 = beta[j], p = p.b[j])* # beta
      dnorm(X$height.fd[ind], mean = mu[j], sd = sigma[j]) # normal
  }
  
  probs = matrix(data = NA, nrow = nrow(X), N)
  
  # forward algorithm to compute the log-likelihood
  foo = delta%*%diag(allprobs[1,])
  l = log(sum(foo))
  phi = foo/sum(foo)
  probs[1,] = phi/sum(phi)
  for (t in 2:nrow(X)){
    foo = phi%*%Gamma%*%diag(allprobs[t,])
    l = l+log(sum(foo))
    phi = foo/sum(foo)
    probs[t,] = phi/sum(phi)
  }
  
  return(probs) 
}


viterbi = function(theta.star, X, N){ 
  n = nrow(X)
  
  Gamma = diag(N)
  Gamma[!Gamma] = exp(theta.star[1:((N-1)*N)])
  Gamma = Gamma/rowSums(Gamma)
  delta = solve(t(diag(N)-Gamma+1),rep(1,N), tol = 1e-20) # stationary, smaller tolerance to avoid numerical problems
  
  # gamma distribution: Step length
  mu.g = exp(theta.star[(N-1)*N+1:N]) # means of gamma distributions
  sigma.g = exp(theta.star[(N-1)*N+N+1:N]) # sds of gamma distributions
  
  # beta distribution: Turning angle/ pi
  alpha = exp(theta.star[(N-1)*N+2*N+1:N]) # shape1 parameters of beta distributions
  beta = exp(theta.star[(N-1)*N+3*N+1:N]) # shape2 parameters of beta distributions
  p.b = plogis(theta.star[(N-1)*N+4*N+1:N])
  
  # normal distribution: Height first difference
  mu = theta.star[(N-1)*N+5*N+1:N] # means of normal distributions
  sigma = exp(theta.star[(N-1)*N+6*N+1:N]) # sds of normal distributions
  
  allprobs = matrix(1, n, N)
  ind = which(!is.na(X$step) & !is.na(X$angle) & !is.na(X$height.fd)) # Fragen wie wir das machen --> sonst immer gar keine Information nur weil in angle Zeitreihe so viele NAs
  
  for (j in 1:N){ # allprobs matrix
    allprobs[ind,j] =
      dgamma(X$step[ind], shape = mu.g[j]^2/sigma.g[j]^2, scale = sigma.g[j]^2/mu.g[j])* #gamma
      zbeta(X$angle[ind], shape1 = alpha[j], shape2 = beta[j], p = p.b[j])* # beta
      dnorm(X$height.fd[ind], mean = mu[j], sd = sigma[j]) # normal
  }
  
  xi = matrix(0, n, ncol = N) 
  foo = delta * allprobs[1, ]
  xi[1, ] = foo / sum(foo)
  for (t in 2:n){
    foo = apply(xi[t - 1, ] * Gamma, 2, max) * allprobs[t, ]
    xi[t, ] = foo / sum(foo) 
    }
  iv <- numeric(n)
  iv[n] <- which.max(xi[n, ]) 
  for (t in (n - 1):1){
    iv[t] <- which.max(Gamma[, iv[t + 1]] * xi[t, ]) }
  return(iv)
}

```


This document is supposed to give a compact overview of the current results that lead to the questions we now face.

## Data preprocessing

Until now we only dealt with the bird ider (as it had the longest time series). We decided for the following preprocessing:

We aggregated each 30 second interval to one data point. The time series we examine now includes:

* Step length/ speed(m/s)
* Turning angle
* Height difference (difference between consecutive heights)

Therefore we first computed Step length and turning angle on a 1 Hz basis within each interval. For Step length we just computed the average as a summary statistic. 

For the turning angle we observed that the soaring behaviour stands out by a more or less constant (slightly fluctuating) turning angle within the 30 second interval. However the turning direction is sometimes right and sometimes left which is not of interest for detecting this behaviour. Therefore for turning angle we computed the absolute value of the mean in each time interval. Afterwards it is scaled by a factor of $1/\pi$ so we can model it using the Beta-distribution. 

For the first difference of the height we also computed this within each interval and then computed the average.

We had to exclude some outliers, especially for height first difference, namely data points that showed an average height first difference above 20 m/s and below -110 m/s. This already leads to the first question: Is this resonable for the animal?

Afterwards the three time series looked like this:


```{r, echo = FALSE, message = FALSE, results = "hide"}
library(moveHMM)
library(tidyverse)
library(sn)

# Load in the data --------------------------------------------------------
setwd("/Users/jan-ole/R/HMM Project")
ider = read.csv("Ider_annotated.csv")
colnames(ider)

ider$height.fd = c(NA, diff(ider$height.above.msl))
# ider$turning2 = c(NA, diff(ider$heading*pi/180))

N = nrow(ider)/30

measurement = rep(1:N, each=30)

d = ider[,5:6]
d$ID = "ID"
colnames(d) = c("x", "y", "ID")
d = prepData(d)

index_stepNA <- (1:N)*30
d$step[index_stepNA] <- NA

index_angleNA <- (1:(N-1))*30+1
d$angle[c(index_stepNA, index_angleNA)] <- NA

# deleting wrong step lengths and angles
# for (i in 1:N){
#   d$step[30*i] = NA
#   d$angle[30*i] = NA
# }
# for (i in 1:(N-1)){
#   d$angle[30*i+1] = NA
# }

data = as.data.frame(cbind(ider,d, measurement))

# aggregation with mean
data2 = data %>% 
  dplyr::select(step, angle, height = height.above.msl, height.fd, measurement, x, y, day, landform, landform.type, elevation = elevation.m, temp = external.temperature, time = solar.time) %>% 
  group_by(measurement) %>% 
  summarise(count_steps = sum(!is.na(step)),
            count_angles = sum(!is.na(angle)), # find intervals where there are barely any values
            count_heights = sum(!is.na(height)),
            step = mean(step, na.rm = T)*1000, # converting to m/s
            angle = abs(mean(angle, na.rm = T))/pi,
            height.fd = mean(diff(height), na.rm = T),
            height = mean(height, na.rm = T),
            x = mean(x, na.rm = T),
            y = mean(y, na.rm = T),
            day = mean(day, na.rm = T),
            landform = as.integer(names(which.max(table(landform)))),
            landform.type = as.character(names(which.max(table(na.omit(landform.type))))),
            elevation = mean(elevation, na.rm = T),
            temp = mean(temp, na.rm = T),
            time = mean(time, na.rm = T)) %>% 
  ungroup() %>% 
  mutate(remove_step_height = (count_steps <= 3 | count_heights <= 3),
         remove_angle = count_angles <= 3)
# seasonal dummy?

data2$step[which(data2$remove_step_height == T)] = NA # set interval with barely any values to NA
data2$height.fd[which(data2$remove_step_height == T)] = NA # set interval with barely any values to NA
data2$angle[which(data2$remove_angle == T)] = NA # set interval with barely any values to NA

data2$height.fd[which(data2$height.fd > 20)] = NA
data2$height.fd[which(data2$height.fd < -110)] = NA

# get rid of point masses
set.seed(123)
data2$angle[which(data2$angle == 1)] = runif(length(data2$angle[which(data2$angle == 1)]), 0.98, 1)
data2$angle[which(data2$angle == 0)] = runif(length(data2$angle[which(data2$angle == 0)]), 0, 0.02)
data2$step[which(data2$step == 0)] = runif(length(data2$step[which(data2$step == 0)]), 0, 0.02)
```

```{r, echo = FALSE}
setwd("/Users/jan-ole/R/EagleHMM")
color = c("deepskyblue", "orange", "springgreen4", "dodgerblue3")

data4 = data2[1:5000,]
par(mfrow = c(3,1))
par(mar = c(2,2,2,2))
plot(data4$step[1:500], type = "h", ylab = "step length")
plot(data4$angle[1:500], type = "h", ylab = "turning angle")
plot(data4$height.fd[1:500], type = "h", ylab = "height (fd.)")
```


One can observe that there are large Step lengths in combination with small turning angles and mostly downward movement, medium Step lengths in combination with turning angles around 0.15 and upward movement as well as barely any step length in combination with different turning angles and basically no vertical movement.


## 3 state HMM

This made a 3 state HMM look reasonable with states:

* State 1: Resting
* State 2: Soaring
* State 2: Gliding/ flying

We formulated this model without covariates and fitted it to the first 5000 observations (which is a one-way trans-himalayan migration). Which results in the transition probabilities and stationary distribution:

```{r, echo = FALSE, message = FALSE}
mod2 = readRDS("mod2.rds")
theta.star = mod2$estimate

states = viterbi_na_sn(theta.star, data2, N = 3)

N = 3
Gamma = diag(N)
Gamma[!Gamma] = exp(theta.star[1:((N-1)*N)])
Gamma = Gamma/rowSums(Gamma)
delta = solve(t(diag(N)-Gamma+1),rep(1,N), tol = 1e-40) # stationary, smaller tolerance to avoid numerical problems

# gamma distribution: Step length
mu.g = exp(theta.star[(N-1)*N+1:N]) # means of gamma distributions
sigma.g = exp(theta.star[(N-1)*N+N+1:N]) # sds of gamma distributions

# beta distribution: Turning angle/ pi
alpha = exp(theta.star[(N-1)*N+2*N+1:N]) # shape1 parameters of beta distributions
beta = exp(theta.star[(N-1)*N+3*N+1:N]) # shape2 parameters of beta distributions

# normal distribution: Height first difference
xi = theta.star[(N-1)*N+4*N+1:N] # means of normal distributions
omega = exp(theta.star[(N-1)*N+5*N+1:N]) # sds of normal distributions
al = theta.star[(N-1)*N+6*N+1:N]
```

Transition probability matrix:
```{r, echo = FALSE}
Gamma
```

Stationary state distribution:
```{r, echo = FALSE}
delta
```

```{r, echo = FALSE}
par(mfrow = c(3,1))
par(mar = c(2,4,1.5,1))
plot(data4$step[1:5000], pch = 20, ylab = "step length", col = color[states[1:5000]])
legend(x = 4500, y = 30, legend=c("State 1", "State 2", "State 3"),
        col=color[1:3], lty = 1, cex=1, bg = "#ffffff")
plot(data4$angle[1:5000], pch = 20, ylab = "turning angle", col = color[states[1:5000]])
plot(data4$height.fd[1:5000], pch = 20, ylab = "height (fd.)", col = color[states[1:5000]])
```

<br>
<br>

```{r, echo = FALSE}
par(mfrow = c(1,1))
par(mar = c(6,4,6,2))
# total
hist(data2$step, prob = T, breaks = 100, xlab = "step length", xlim = c(0,30), main = "marginal distribution: Step length")
curve(delta[1]*dgamma(x, shape = mu.g[1]^2/sigma.g[1]^2, scale = sigma.g[1]^2/mu.g[1]), add = T, lwd = 2, col = color[1])
curve(delta[2]*dgamma(x, shape = mu.g[2]^2/sigma.g[2]^2, scale = sigma.g[2]^2/mu.g[2]), add = T, lwd = 2, col = color[2])
curve(delta[3]*dgamma(x, shape = mu.g[3]^2/sigma.g[3]^2, scale = sigma.g[3]^2/mu.g[3]), add = T, lwd = 2, col = color[3], n = 1000)

curve(
  delta[1]*dgamma(x, shape = mu.g[1]^2/sigma.g[1]^2, scale = sigma.g[1]^2/mu.g[1])+
    delta[2]*dgamma(x, shape = mu.g[2]^2/sigma.g[2]^2, scale = sigma.g[2]^2/mu.g[2])+ 
    delta[3]*dgamma(x, shape = mu.g[3]^2/sigma.g[3]^2, scale = sigma.g[3]^2/mu.g[3]),
  add = T, lty = "dashed", lwd = 2, n = 1000
)
# Mass around zero not captured accurately
# Maybe 4th state small movements??
```


Here we can observe a lack of fit as the model overestimates how often step lengths of 2-6 meters should appear.


```{r, echo = FALSE}
par(mar = c(6,4,6,2))
hist(data2$angle, prob = T, breaks = 50, xlab = "turning angle", xlim = c(0,1), main = "marginal distribution: Turning angle")
curve(delta[1]*dbeta(x, shape1 = alpha[1], shape2 = beta[1]), add = T, lwd = 2, col = color[1])
curve(delta[2]*dbeta(x, shape1 = alpha[2], shape2 = beta[2]), add = T, lwd = 2, col = color[2])
curve(delta[3]*dbeta(x, shape1 = alpha[3], shape2 = beta[3]), add = T, lwd = 2, col = color[3])

curve(
  delta[1]*dbeta(x, shape1 = alpha[1], shape2 = beta[1])+
    delta[2]*dbeta(x, shape1 = alpha[2], shape2 = beta[2])+
    delta[3]*dbeta(x, shape1 = alpha[3], shape2 = beta[3]),
  add = T, lty = "dashed", lwd = 2
)
```

<br>
<br>

```{r, echo = FALSE}
par(mar = c(6,4,6,2))
hist(data2$height.fd, prob = T, breaks = 200, xlab = "height (fd.)", xlim = c(-5,5), main = "marginal distribution: Height (fd.)")

curve(delta[1]*dsn(x, xi[1], omega[1], alpha = al[1]), add = T, lwd = 2, col = color[1])
curve(delta[2]*dsn(x, xi[2], omega[2], alpha = al[2]), add = T, lwd = 2, col = color[2])
curve(delta[3]*dsn(x, xi[3], omega[3], alpha = al[3]), add = T, lwd = 2, col = color[3],n =1000)
```

So overall this model already looks promising. However the distinction between soaring and gliding is not as clear as we hoped. This is observable in the marginal plot above as well as in the scatterplot:

```{r, echo = FALSE}
plot(data4$height.fd[1:1000], type = "h", ylab = "height (fd.)", col = color[states[1:2000]],
     main = "time series plot: Height (fd.)")
```

The model often also decodes upward movement as state 2 which should reflect only gliding. Therefore we looked into four state models.

## 4 state HMMs

### 4 state Model without covariates

First we fitted a four state HMM without covariates with the aim of finding a model that better seperates states 2 and 3. This yielded the following results:

```{r, echo = FALSE, message=FALSE, results=FALSE}
mod2.4_2 = readRDS("mod2.4_2.rds")
theta.star = mod2.4_2$estimate
data4 = data2[1:5000,]
states = viterbi_na_sn(theta.star, data4, N = 4)

N = 4
Gamma = diag(N)
Gamma[!Gamma] = exp(theta.star[1:((N-1)*N)])
Gamma = Gamma/rowSums(Gamma)
delta = solve(t(diag(N)-Gamma+1),rep(1,N), tol = 1e-18) # stationary, smaller tolerance to avoid numerical problems

# gamma distribution: Step length
mu.g = exp(theta.star[(N-1)*N+1:N]) # means of gamma distributions
sigma.g = exp(theta.star[(N-1)*N+N+1:N]) # sds of gamma distributions

# beta distribution: Turning angle/ pi
alpha = exp(theta.star[(N-1)*N+2*N+1:N]) # shape1 parameters of beta distributions
beta = exp(theta.star[(N-1)*N+3*N+1:N]) # shape2 parameters of beta distributions

# normal distribution: Height first difference
xi = theta.star[(N-1)*N+4*N+1:N] # means of normal distributions
omega = exp(theta.star[(N-1)*N+5*N+1:N]) # sds of normal distributions
al = theta.star[(N-1)*N+6*N+1:N]

```

Transition probability matrix:
```{r, echo = F}
Gamma
```

Stationary state distribution:
```{r, echo = F}
delta
```

```{r, echo = FALSE}
par(mfrow = c(1,1))
# total
hist(data4$step, prob = T, breaks = 200, xlab = "step length", main = "marginal distribution: Step length")
curve(delta[1]*dgamma(x, shape = mu.g[1]^2/sigma.g[1]^2, scale = sigma.g[1]^2/mu.g[1]), add = T, lwd = 2, col = color[1])
curve(delta[2]*dgamma(x, shape = mu.g[2]^2/sigma.g[2]^2, scale = sigma.g[2]^2/mu.g[2]), add = T, lwd = 2, col = color[2])
curve(delta[3]*dgamma(x, shape = mu.g[3]^2/sigma.g[3]^2, scale = sigma.g[3]^2/mu.g[3]), add = T, lwd = 2, col = color[3],n = 500)
curve(delta[4]*dgamma(x, shape = mu.g[4]^2/sigma.g[4]^2, scale = sigma.g[4]^2/mu.g[4]), add = T, lwd = 2, col = color[4],n = 500)

curve(
  delta[1]*dgamma(x, shape = mu.g[1]^2/sigma.g[1]^2, scale = sigma.g[1]^2/mu.g[1])+
    delta[2]*dgamma(x, shape = mu.g[2]^2/sigma.g[2]^2, scale = sigma.g[2]^2/mu.g[2])+ 
    delta[3]*dgamma(x, shape = mu.g[3]^2/sigma.g[3]^2, scale = sigma.g[3]^2/mu.g[3])+
    delta[4]*dgamma(x, shape = mu.g[4]^2/sigma.g[4]^2, scale = sigma.g[4]^2/mu.g[4]),
  add = T, lty = "dashed", lwd = 2, n = 500
)

```


The fourth state fixes the problem with overestimation of step lengths between 2 and 6 meters so it seems to be necessary. This points us to the fact that there is a fourth behaviour which is "active resting" that the 3 state model could not capture appropriately. More on this later.

<br>

```{r, echo = FALSE}
par(mfrow = c(1,1))

hist(data4$angle, prob = T, breaks = 50, xlab = "turning angle", xlim = c(0,1), main = "marginal distribution: Turning angle")
curve(delta[1]*dbeta(x, shape1 = alpha[1], shape2 = beta[1]), add = T, lwd = 2, col = color[1])
curve(delta[2]*dbeta(x, shape1 = alpha[2], shape2 = beta[2]), add = T, lwd = 2, col = color[2])
curve(delta[3]*dbeta(x, shape1 = alpha[3], shape2 = beta[3]), add = T, lwd = 2, col = color[3])
curve(delta[4]*dbeta(x, shape1 = alpha[4], shape2 = beta[4]), add = T, lwd = 2, col = color[4], n = 500)

curve(
  delta[1]*dbeta(x, shape1 = alpha[1], shape2 = beta[1])+
    delta[2]*dbeta(x, shape1 = alpha[2], shape2 = beta[2])+
    delta[3]*dbeta(x, shape1 = alpha[3], shape2 = beta[3])+
    delta[4]*dbeta(x, shape1 = alpha[4], shape2 = beta[4]),
  add = T, lty = "dashed", lwd = 2
)
```

<br>
<br>

```{r, echo = FALSE}
par(mfrow = c(1,1))

hist(data4$height.fd, prob = T, breaks = 200, xlab = "height (fd.)", xlim = c(-5,5), main = "marginal distribution: Height (fd.)")
curve(delta[1]*dsn(x, xi[1], omega[1], al[1]), add = T, lwd = 2, col = color[1], n = 500)
curve(delta[2]*dsn(x, xi[2], omega[2], al[2]), add = T, lwd = 2, col = color[2])
curve(delta[3]*dsn(x, xi[3], omega[3], al[3]), add = T, lwd = 2, col = color[3])
curve(delta[4]*dsn(x, xi[4], omega[4], al[4]), add = T, lwd = 2, col = color[4])


curve(
  delta[1]*dsn(x, xi[1], omega[1], al[1])+
    delta[2]*dsn(x, xi[2], omega[2], al[2])+
    delta[3]*dsn(x, xi[3], omega[3], al[3])+
    delta[4]*dsn(x, xi[4], omega[4], al[4])
  ,
  add = T, lty = "dashed", lwd = 2, n=1000
)
```

<br>
<br>

```{r, echo = FALSE}
data4 = data2[1:5000,]
par(mfrow = c(3,1))
par(mar = c(2,4,1.5,1))
plot(data4$step[1:5000], pch = 20, col = color[states[1:5000]], ylab = "step length", main = "scatterplot")
legend(x = 4500, y = 30, legend=c("State 1", "State 2", "State 3", "State 4"),
        col=color, lty = 1, cex=1, bg = "#ffffff")
plot(data4$angle[1:5000], pch = 20, col = color[states[1:5000]], ylab = "turning angle")
plot(data4$height.fd[1:5000], pch = 20, col = color[states[1:5000]], ylab = "height (fd.)")

```

Here states 1 to 3 are basically characterised by the same characteristics as in the three state HMM. The new fourth state we interpreted as some kind of resting behaviour as well but distinctly more active then the resting behaviour captured in state 1 as the step length is longer, there is less variability in the turning angles and more vertical movement.
Introducing this fourth state leads to a clearer distincion between soaring and gliding.

<br><br>

### 4 state Models with covariates

#### Temperature

Now that we got that far we started introducing covariates into the state switching process by expressing the transition probabilities as functions of those covariates. We started by introducing a dependency on the temperature.

```{r, echo = FALSE}
setwd("/Users/jan-ole/R/EagleHMM")
mod6 = readRDS("mod6.rds")
theta.star = mod6$estimate
states = viterbi_na_sn_cov2(mod6$estimate, X = data2[1:5000,], N = 4)
```

```{r, echo = FALSE}
data4 = data2[1:5000,]
par(mfrow = c(3,1))
par(mar = c(2,4,1.5,1))
plot(data4$step[1:5000], pch = 20, col = color[states[1:5000]], ylab = "step length", main = "scatterplot")
legend(x = 4500, y = 30, legend=c("State 1", "State 2", "State 3", "State 4"),
       col=color, lty = 1, cex=1)
plot(data4$angle[1:5000], pch = 20, col = color[states[1:5000]], ylab = "turning angle")
plot(data4$height.fd[1:5000], pch = 20, col = color[states[1:5000]], ylab = "height (fd.)")
```

This model seperates states 2 and 3 even better. Overall however the decoded states have not changed much. 

We can now look at the hypothetical stationary state distribution as well as the transition probabilities depending on the external temperature:

```{r, echo = FALSE}
tempseq = seq(from = min(data4$temp),to = max(data4$temp), length.out = 500)
h_delta = solve_gamma_na_sn_cov(mod6$estimate, tempseq, 4)

par(mfrow = c(1,1))
plot(tempseq, h_delta[,1], type = "l", lwd = 2, col = color[1], ylim = c(0,1), main = "hypothetical stationary distribution", ylab = "stationary state probabilities", xlab = "temperature")
lines(tempseq, h_delta[,2], lwd = 2, col = color[2])
lines(tempseq, h_delta[,3], lwd = 2, col = color[3])
lines(tempseq, h_delta[,4], lwd = 2, col = color[4])
legend(15, 1, legend=c("State 1", "State 2", "State 3", "State 4"),
       col=color, lty = 1, cex=1, box.lwd = 0)

```

##### Transition probabilities as a function of temperature

```{r, echo = FALSE}
# Transition probabilities

transprobs_temp = get_transprobs(mod6$estimate, tempseq)

par(mfrow = c(4,4))
par(mar = c(3, 4, 1, 1))
for (i in 1:16){
  if(i %in% 1:4){st = 1}
  if(i %in% 5:8){st = 2}
  if(i %in% 9:12){st = 3}
  if(i %in% 13:16){st = 4}
  plot(tempseq, transprobs_temp[,i], main = NULL, 
       ylab = colnames(transprobs_temp)[i], xlab = "time of day", 
       type = "l", lwd = 2, col = color[st], ylim = c(0,1))
}

```

As the transition probabilities depend on the temperature we cannot plot the component distributions against the histogram using the stationary distribution. However we can replace the stationary distribution by the relative frequency of the decoded states in this case. This way we still optain the following plots:

```{r, echo = FALSE}
N = 4
coef = matrix(theta.star[1:(2*(N-1)*N)], (N-1)*N, 2)
mu.g = exp(theta.star[2*(N-1)*N+1:N]) # means of gamma distributions
sigma.g = exp(theta.star[2*(N-1)*N+N+1:N]) # sds of gamma distributions
alpha = exp(theta.star[2*(N-1)*N+2*N+1:N]) # shape1 parameters of beta distributions
beta = exp(theta.star[2*(N-1)*N+3*N+1:N]) # shape2 parameters of beta distributions
xi = theta.star[2*(N-1)*N+4*N+1:N] # means of normal distributions
omega = exp(theta.star[2*(N-1)*N+5*N+1:N]) # sds of normal distributions
al = theta.star[2*(N-1)*N+6*N+1:N]

delta_star = c(sum(states == 1), sum(states == 2), sum(states == 3), sum(states == 4))
delta_star = delta_star/sum(delta_star)

par(mfrow = c(1,1))

# Step length
hist(data4$step, prob = T, breaks = 100, main = "Histogram of step length", xlab = "step length")
curve(delta_star[1]*dgamma(x, shape = mu.g[1]^2/sigma.g[1]^2, scale = sigma.g[1]^2/mu.g[1]), add = T, lwd = 2, col = color[1], n = 500)
curve(delta_star[2]*dgamma(x, shape = mu.g[2]^2/sigma.g[2]^2, scale = sigma.g[2]^2/mu.g[2]), add = T, lwd = 2, col = color[2], n = 500)
curve(delta_star[3]*dgamma(x, shape = mu.g[3]^2/sigma.g[3]^2, scale = sigma.g[3]^2/mu.g[3]), add = T, lwd = 2, col = color[3], n = 500)
curve(delta_star[4]*dgamma(x, shape = mu.g[4]^2/sigma.g[4]^2, scale = sigma.g[4]^2/mu.g[4]), add = T, lwd = 2, col = color[4], n = 500)

curve(
  delta_star[1]*dgamma(x, shape = mu.g[1]^2/sigma.g[1]^2, scale = sigma.g[1]^2/mu.g[1])+
    delta_star[2]*dgamma(x, shape = mu.g[2]^2/sigma.g[2]^2, scale = sigma.g[2]^2/mu.g[2])+ 
    delta_star[3]*dgamma(x, shape = mu.g[3]^2/sigma.g[3]^2, scale = sigma.g[3]^2/mu.g[3])+
    delta_star[4]*dgamma(x, shape = mu.g[4]^2/sigma.g[4]^2, scale = sigma.g[4]^2/mu.g[4]),
  add = T, lty = "dashed", lwd = 2, n = 500
)

```


```{r, echo = FALSE}
# Turning angle
par(mfrow = c(1,1))

hist(data4$angle, prob = T, breaks = 50, main = "Histogram of turning angle", xlab = "turning angle", xlim = c(0,1))
curve(delta_star[1]*dbeta(x, shape1 = alpha[1], shape2 = beta[1]), add = T, lwd = 2, col = color[1], n = 500)
curve(delta_star[2]*dbeta(x, shape1 = alpha[2], shape2 = beta[2]), add = T, lwd = 2, col = color[2], n = 500)
curve(delta_star[3]*dbeta(x, shape1 = alpha[3], shape2 = beta[3]), add = T, lwd = 2, col = color[3], n = 500)
curve(delta_star[4]*dbeta(x, shape1 = alpha[4], shape2 = beta[4]), add = T, lwd = 2, col = color[4], n = 500)

curve(
  delta_star[1]*dbeta(x, shape1 = alpha[1], shape2 = beta[1])+
    delta_star[2]*dbeta(x, shape1 = alpha[2], shape2 = beta[2])+
    delta_star[3]*dbeta(x, shape1 = alpha[3], shape2 = beta[3])+
    delta_star[4]*dbeta(x, shape1 = alpha[4], shape2 = beta[4]),
  add = T, lty = "dashed", lwd = 2
)
```


```{r, echo = FALSE}
# Height (fd.)
par(mfrow = c(1,1))

hist(data4$height.fd, prob = T, breaks = 190, main = "Histogram of height (fd.)", xlab = "height (fd.)", xlim = c(-5,5), ylim = c(0, 1.8))
curve(delta_star[1]*dsn(x, xi[1], omega[1], al[1]), add = T, lwd = 2, col = color[1], n = 1000)
curve(delta_star[2]*dsn(x, xi[2], omega[2], al[2]), add = T, lwd = 2, col = color[2])
curve(delta_star[3]*dsn(x, xi[3], omega[3], al[3]), add = T, lwd = 2, col = color[3])
curve(delta_star[4]*dsn(x, xi[4], omega[4], al[4]), add = T, lwd = 2, col = color[4])

curve(
  delta_star[1]*dsn(x, xi[1], omega[1], al[1])+
    delta_star[2]*dsn(x, xi[2], omega[2], al[2])+
    delta_star[3]*dsn(x, xi[3], omega[3], al[3])+
    delta_star[4]*dsn(x, xi[4], omega[4], al[4]),
  add = T, lty = "dashed", lwd = 2, n = 1000
)
```

Especially here we can see that this model better seperates downwards and upwards movement when looking at the orange and green distributions for states 2 and 3 respectively.

<br><br>

#### Time of day

The next model we fitted used the covariate Time of day to explain the transitions.

```{r, echo = FALSE}
setwd("/Users/jan-ole/R/EagleHMM")
mod8 = readRDS("mod8.rds")
theta.star = mod8$estimate
states = viterbi_tod(mod8$estimate, X = data2[1:5000,], N = 4)
```

```{r, echo = FALSE}
data4 = data2[1:5000,]
par(mfrow = c(3,1))
par(mar = c(2,4,1.5,1))
plot(data4$step[1:5000], pch = 20, col = color[states[1:5000]], ylab = "step length")
legend(x = 4500, y = 30, legend=c("State 1", "State 2", "State 3", "State 4"),
       col=color, lty = 1, cex=1)
plot(data4$angle[1:5000], pch = 20, col = color[states[1:5000]], ylab = "turning angle")
plot(data4$height.fd[1:5000], pch = 20, col = color[states[1:5000]], ylab = "height (fd.)")

```


```{r, echo = FALSE}
todseq = seq(min(data4$time), max(data4$time), length.out = 500)
h_delta = solve_gamma_tod(mod8$estimate, todseq, 4)

par(mfrow = c(1,1))
plot(todseq, h_delta[,1], type = "l", lwd = 2, col = color[1], ylim = c(0,1), main = "hypothetical stationary distribution", ylab = "stationary state probabilities", xlab = "time of day")
lines(todseq, h_delta[,2], lwd = 2, col = color[2])
lines(todseq, h_delta[,3], lwd = 2, col = color[3])
lines(todseq, h_delta[,4], lwd = 2, col = color[4])
legend(11, 1, legend=c("State 1", "State 2", "State 3", "State 4"),
       col=color, lty = 1, cex=1, box.lwd = 0)

```

##### Transition probabilities as a function of time of day

```{r, echo = FALSE}
transprobs_tod = get_transprobs_tod(mod8$estimate, todseq)

par(mfrow = c(4,4))
par(mar = c(4.5, 4.5, 1.5, 2))
for (i in 1:16){
  if(i %in% 1:4){st = 1}
  if(i %in% 5:8){st = 2}
  if(i %in% 9:12){st = 3}
  if(i %in% 13:16){st = 4}
  plot(todseq, transprobs_tod[,i], main = NULL, 
       ylab = colnames(transprobs_tod)[i], xlab = "time of day", 
       type = "l", lwd = 2, col = color[st], ylim = c(0,1))
}
```

```{r, echo = FALSE}
delta_star = c(sum(states == 1), sum(states == 2), sum(states == 3), sum(states == 4))
delta_star = delta_star/sum(delta_star)

coef = matrix(theta.star[1:(3*(N-1)*N)], (N-1)*N, 3)

mu.g = exp(theta.star[3*(N-1)*N+1:N]) # means of gamma distributions
sigma.g = exp(theta.star[3*(N-1)*N+N+1:N]) # sds of gamma distributions
alpha = exp(theta.star[3*(N-1)*N+2*N+1:N]) # shape1 parameters of beta distributions
beta = exp(theta.star[3*(N-1)*N+3*N+1:N]) # shape2 parameters of beta distributions
xi = theta.star[3*(N-1)*N+4*N+1:N] # means of normal distributions
omega = exp(theta.star[3*(N-1)*N+5*N+1:N]) # sds of normal distributions
al = theta.star[3*(N-1)*N+6*N+1:N]
```

```{r, echo = FALSE}
par(mfrow = c(1,1))

# Step length
hist(data4$step, prob = T, breaks = 100, main = "Histogram of step length", xlab = "step length")
curve(delta_star[1]*dgamma(x, shape = mu.g[1]^2/sigma.g[1]^2, scale = sigma.g[1]^2/mu.g[1]), add = T, lwd = 2, col = color[1], n = 500)
curve(delta_star[2]*dgamma(x, shape = mu.g[2]^2/sigma.g[2]^2, scale = sigma.g[2]^2/mu.g[2]), add = T, lwd = 2, col = color[2], n = 500)
curve(delta_star[3]*dgamma(x, shape = mu.g[3]^2/sigma.g[3]^2, scale = sigma.g[3]^2/mu.g[3]), add = T, lwd = 2, col = color[3], n = 500)
curve(delta_star[4]*dgamma(x, shape = mu.g[4]^2/sigma.g[4]^2, scale = sigma.g[4]^2/mu.g[4]), add = T, lwd = 2, col = color[4], n = 500)

curve(
  delta_star[1]*dgamma(x, shape = mu.g[1]^2/sigma.g[1]^2, scale = sigma.g[1]^2/mu.g[1])+
    delta_star[2]*dgamma(x, shape = mu.g[2]^2/sigma.g[2]^2, scale = sigma.g[2]^2/mu.g[2])+ 
    delta_star[3]*dgamma(x, shape = mu.g[3]^2/sigma.g[3]^2, scale = sigma.g[3]^2/mu.g[3])+
    delta_star[4]*dgamma(x, shape = mu.g[4]^2/sigma.g[4]^2, scale = sigma.g[4]^2/mu.g[4]),
  add = T, lty = "dashed", lwd = 2, n = 500
)
```


```{r, echo = FALSE}
hist(data4$angle, prob = T, breaks = 50, main = "Histogram of turning angle", xlab = "turning angle", xlim = c(0,1))
curve(delta_star[1]*dbeta(x, shape1 = alpha[1], shape2 = beta[1]), add = T, lwd = 2, col = color[1], n = 500)
curve(delta_star[2]*dbeta(x, shape1 = alpha[2], shape2 = beta[2]), add = T, lwd = 2, col = color[2], n = 500)
curve(delta_star[3]*dbeta(x, shape1 = alpha[3], shape2 = beta[3]), add = T, lwd = 2, col = color[3], n = 500)
curve(delta_star[4]*dbeta(x, shape1 = alpha[4], shape2 = beta[4]), add = T, lwd = 2, col = color[4], n = 500)

curve(
  delta_star[1]*dbeta(x, shape1 = alpha[1], shape2 = beta[1])+
    delta_star[2]*dbeta(x, shape1 = alpha[2], shape2 = beta[2])+
    delta_star[3]*dbeta(x, shape1 = alpha[3], shape2 = beta[3])+
    delta_star[4]*dbeta(x, shape1 = alpha[4], shape2 = beta[4]),
  add = T, lty = "dashed", lwd = 2
)
```


```{r, echo = FALSE}
# Height (fd.)
par(mfrow = c(1,1))

hist(data4$height.fd, prob = T, breaks = 190, main = "Histogram of height (fd.)", xlab = "height (fd.)", xlim = c(-5,5), ylim = c(0, 1.8))
curve(delta_star[1]*dsn(x, xi[1], omega[1], al[1]), add = T, lwd = 2, col = color[1], n = 1000)
curve(delta_star[2]*dsn(x, xi[2], omega[2], al[2]), add = T, lwd = 2, col = color[2])
curve(delta_star[3]*dsn(x, xi[3], omega[3], al[3]), add = T, lwd = 2, col = color[3])
curve(delta_star[4]*dsn(x, xi[4], omega[4], al[4]), add = T, lwd = 2, col = color[4])

curve(
  delta_star[1]*dsn(x, xi[1], omega[1], al[1])+
    delta_star[2]*dsn(x, xi[2], omega[2], al[2])+
    delta_star[3]*dsn(x, xi[3], omega[3], al[3])+
    delta_star[4]*dsn(x, xi[4], omega[4], al[4]),
  add = T, lty = "dashed", lwd = 2, n = 1000
)
```

<br><br>

#### Temperature and Time of Day

The latest model uses both: Temperature and time of day as covariates. This model is so far the best in terms of BIC.

```{r, echo = FALSE}
setwd("/Users/jan-ole/R/EagleHMM")
mod9 = readRDS("mod9.rds")
theta.star = mod9$estimate
states = viterbi_tt(mod9$estimate, X = data2[1:5000,], N = 4)
```

```{r, echo = FALSE}
data4 = data2[1:5000,]
par(mfrow = c(3,1))
par(mar = c(2,4,1.5,1))

plot(data4$step[1:5000], pch = 20, col = color[states[1:5000]], ylab = "step length")
legend(x = 4500, y = 30, legend=c("State 1", "State 2", "State 3", "State 4"),
       col=color, lty = 1, cex=1)
plot(data4$angle[1:5000], pch = 20, col = color[states[1:5000]], ylab = "turning angle")
plot(data4$height.fd[1:5000], pch = 20, col = color[states[1:5000]], ylab = "height (fd.)")

```

<br><br>

```{r, echo = FALSE}
# Hypothetical stationary
todseq = seq(min(data4$time), max(data4$time), length.out = 500)
tempseq = seq(min(data4$temp), max(data4$temp), length.out = 500)

h_delta1 = solve_gamma_tt1(mod9$estimate, todseq, mean(data4$temp), 4)
h_delta2 = solve_gamma_tt2(mod9$estimate, tempseq, mean(data4$time), 4)

# Plot for time of day
par(mfrow = c(1,2))
plot(todseq, h_delta1[,1], type = "l", lwd = 2, col = color[1], ylim = c(0,1), main = "hypothetical stationary", ylab = "stationary state probabilities", xlab = "time of day")
lines(todseq, h_delta1[,2], lwd = 2, col = color[2])
lines(todseq, h_delta1[,3], lwd = 2, col = color[3])
lines(todseq, h_delta1[,4], lwd = 2, col = color[4])
legend(8.5, 1, legend=c("State 1", "State 2", "State 3", "State 4"),
       col=color, lty = 1, cex=1, box.lwd = 0)

# Plot for temperature
plot(tempseq, h_delta2[,1], type = "l", lwd = 2, col = color[1], ylim = c(0,1), main = "hypothetical stationary", ylab = "stationary state probabilities", xlab = "temperature")
lines(tempseq, h_delta2[,2], lwd = 2, col = color[2])
lines(tempseq, h_delta2[,3], lwd = 2, col = color[3])
lines(tempseq, h_delta2[,4], lwd = 2, col = color[4])
legend(15, 1, legend=c("State 1", "State 2", "State 3", "State 4"),
       col=color, lty = 1, cex=1, box.lwd = 0)


```
<br><br>

##### Transition probabilities for time of day

```{r, echo = FALSE}
# Transition probabilities

transprobs_tt1 = get_transprobs_tt1(mod9$estimate, todseq, mean(data4$temp))
transprobs_tt2 = get_transprobs_tt2(mod9$estimate, tempseq, mean(data4$time))

# Plot for time of day
par(mfrow = c(4,4))
par(mar = c(4.5, 4.5, 1.5, 2))
for (i in 1:16){
  if(i %in% 1:4){st = 1}
  if(i %in% 5:8){st = 2}
  if(i %in% 9:12){st = 3}
  if(i %in% 13:16){st = 4}
  plot(todseq, transprobs_tt1[,i], main = NULL, 
       ylab = colnames(transprobs_tt1)[i], xlab = "time of day", 
       type = "l", lwd = 2, col = color[st], ylim = c(0,1))
}
```
<br><br>

##### Transition probabilities for temperature

```{r, echo = FALSE}
# Plot for temperature
par(mfrow = c(4,4))
par(mar = c(4.5, 4.5, 1.5, 2))
for (i in 1:16){
  if(i %in% 1:4){st = 1}
  if(i %in% 5:8){st = 2}
  if(i %in% 9:12){st = 3}
  if(i %in% 13:16){st = 4}
  plot(tempseq, transprobs_tt2[,i], main = NULL, 
       ylab = colnames(transprobs_tt2)[i], xlab = "temperature", 
       type = "l", lwd = 2, col = color[st], ylim = c(0,1))
}

```

#### Landform

We also fitted a model using the categorical variable landform. These were the results:

```{r, echo = FALSE, message = FALSE}
library(fastDummies)

data4 = data2[1:5000,]
data5 = dummy_cols(data4, select_columns = "landform.type", remove_first_dummy = TRUE)
colnames(data5)[19:23] = c("lower_slope", "mountain_divide", "peak_ridge", "upper_slope", "valley")

# t1 = Sys.time()
# mod10 = nlm(f = mllk_landform, p = theta.star0.l, X = data5, N = 4, print.level = 2, iterlim = 2000, steptol = 1e-15)
# Sys.time()-t1

mod10 = readRDS("mod10.rds")

theta.star = mod10$estimate
states = viterbi_landform(mod10$estimate, data5, N = 4)

```


```{r, echo = FALSE, message = FALSE}
# Results -----------------------------------------------------------------

color = c("deepskyblue", "orange", "springgreen4", "dodgerblue3")

# Scatterplot

data4 = data2[1:5000,]
par(mfrow = c(3,1))
par(mar = c(2,4,1.5,1))
plot(data4$step[1:5000], pch = 20, col = color[states[1:5000]], ylab = "Step lenght")
legend(x = 4500, y = 30, legend=c("State 1", "State 2", "State 3", "State 4"),
       col=color, lty = 1, cex=1)
plot(data4$angle[1:5000], pch = 20, col = color[states[1:5000]], ylab = "Turning angle")
plot(data4$height.fd[1:5000], pch = 20, col = color[states[1:5000]], ylab = "Height (fd.)")

```

We can also have a look at the hypothetical stationary distribution and transition probabilities as functions of the landform:

```{r, echo = FALSE, message = FALSE}
# Hypothetical stationary

stat = solve_gamma_landform(mod10$estimate, N = 4)

library(graphics)
par(mfrow = c(1,1))

plot(stat$landform, rep(2,6), pch = 16, col = color[1], ylim = c(0,1), main = "Hypothetical stationary distribution", ylab = "Stationary state probabilities", xlab = "landform type")
points(stat$landform, stat$delta[,1], type = "l", lty = "dashed", col = color[1], ylim = c(0,1), main = "Hypothetical stationary distribution", ylab = "Stationary state probabilities", xlab = "time of day")
points(stat$landform, stat$delta[,1], pch = 16, col = color[1], ylim = c(0,1), main = "Hypothetical stationary distribution", ylab = "Stationary state probabilities", xlab = "time of day")
points(stat$landform, stat$delta[,2], type = "l", lty = "dashed", col = color[2], ylim = c(0,1), main = "Hypothetical stationary distribution", ylab = "Stationary state probabilities", xlab = "time of day")
points(stat$landform, stat$delta[,2], pch = 16, col = color[2], ylim = c(0,1), main = "Hypothetical stationary distribution", ylab = "Stationary state probabilities", xlab = "time of day")
points(stat$landform, stat$delta[,3], type = "l", lty = "dashed", col = color[3], ylim = c(0,1), main = "Hypothetical stationary distribution", ylab = "Stationary state probabilities", xlab = "time of day")
points(stat$landform, stat$delta[,3], pch = 16, col = color[3], ylim = c(0,1), main = "Hypothetical stationary distribution", ylab = "Stationary state probabilities", xlab = "time of day")
points(stat$landform, stat$delta[,4], type = "l", lty = "dashed", col = color[4], ylim = c(0,1), main = "Hypothetical stationary distribution", ylab = "Stationary state probabilities", xlab = "time of day")
points(stat$landform, stat$delta[,4], pch = 16, col = color[4], ylim = c(0,1), main = "Hypothetical stationary distribution", ylab = "Stationary state probabilities", xlab = "time of day")

```


(C = Cliff, LS = Lower/ Slope, MD = Mountain/ Divide, PR = Peak/ Ridge, US = Upper slope, V = Valley)

```{r, echo = FALSE, message = FALSE}
# Transition probabilities

transprobs = get_transprobs_landform(mod10$estimate)

par(mfrow = c(4,4))
par(mar = c(4.5, 4.5, 1.5, 2))
for (i in 1:16){
  if(i %in% 1:4){st = 1}
  if(i %in% 5:8){st = 2}
  if(i %in% 9:12){st = 3}
  if(i %in% 13:16){st = 4}
  plot(transprobs$landform, rep(2,6), main = NULL, 
       ylab = colnames(transprobs$transprobs)[i], xlab = "landform type", 
       type = "l", lwd = 2, col = color[st], ylim = c(0,1))
  points(transprobs$landform, transprobs$transprobs[,i], type = "l", lty = "dashed", col = color[st],)
  points(transprobs$landform, transprobs$transprobs[,i], pch = 16, col = color[st],)
}
```


## Multinomial regression for landform

In addition to the large HMM with landform as covariate we fitted a multinomial regression model to the decoded states, which in theory is not acutally the right way to do as the data points are not independent, however the results are easier to interpret. They are shown below. State 2 is chosen as reference and the coefficients for Cliff are in the Intercept column.

```{r, echo = FALSE, message = FALSE, warning = F}
library(nnet)

data4$states = states
# colnames(data4)
data5 = data4 %>% select(states, l_ = landform.type, temp, elevation)
data5$l_ = as.factor(data5$l_)
data5$states = relevel(as.factor(data5$states), ref = "2")
data5$elevation.fd = c(NA, diff(data5$elevation))

m = multinom(states ~ l_ + temp + elevation, data = data5)
summary(m)
```


## Questions

These results lead to the following questions:

* We had some observations way below sealevel. Are these just measurement errors?
* In your first document you stated we might find flapping flight behaviour by using acceleration data. However we could not find a variable corresponding to this. What did you mean by acceleration data?
* As shown above we currently have two resting behaviours. One with really low activity levels and a more active one. At least the data leads us this way. Does this make sense from a biological perspective?
* Currently we are only using the first 5000 measurement Intervals of ider (from approx. 40,000) as this part of the dataset already contains one trans-himalayan migration. This is due to the fact that the day variable has many errors from about interval 6000 onwards. Is this okay or would it be necessary to use the whole time series?
* As shown above we fitted a model with temperature and time and one with landform. We actually also fitted a model with all variables but the results are really hard to show as the plots are quite complicated and messy. The effects of temperature and time of day on the transition probabilities to soaring and gliding are quiet plausible for us, but for landform we are missing biological expertise. Which variables are the most interesting to you?
* Do you want to have us fit models for all birds? This could be done joint or seperately, with joint meaning the paramters for the transition probability matrix being estimated the same over all birds. Is it reasonable to assume that the state switching dynamics (depending to the external variables) are the same for all birds?
* Overall can you answer your research question with these results or do you need more? If not, could you state your research question more precisely?
* In general: Do you like us doing more interpretation or do you just want the results quite raw to interpret them by yourself?